<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>music-recommendation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="music-recommendation_files/libs/clipboard/clipboard.min.js"></script>
<script src="music-recommendation_files/libs/quarto-html/quarto.js"></script>
<script src="music-recommendation_files/libs/quarto-html/popper.min.js"></script>
<script src="music-recommendation_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="music-recommendation_files/libs/quarto-html/anchor.min.js"></script>
<link href="music-recommendation_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="music-recommendation_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="music-recommendation_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="music-recommendation_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="music-recommendation_files/libs/bootstrap/bootstrap-10daa034703793678e481cc8cee6d76f.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<style>



/* Hide scrollbar for the floating TOC only */
#quarto-margin-sidebar {
  scrollbar-width: none !important;         /* Firefox */
  -ms-overflow-style: none !important;      /* Internet Explorer */
}

#quarto-margin-sidebar::-webkit-scrollbar {
  display: none !important;                 /* Chrome, Safari, Edge */
}

/* Also target the TOC itself just in case */
#TOC {
  overflow-y: hidden !important;
  scrollbar-width: none !important;
}

#TOC::-webkit-scrollbar {
  display: none !important;
}

#quarto-margin-sidebar {
  direction: ltr; /* Force left-to-right layout */
}

#quarto-margin-sidebar nav#TOC {
  direction: ltr;         /* Ensure scrollbar is on the right */
  overflow-y: auto !important; /* Restore scroll if needed */
}
#quarto-margin-sidebar::-webkit-scrollbar {
  width: 6px;
}

#quarto-margin-sidebar::-webkit-scrollbar-thumb {
  background-color: #ccc;
  border-radius: 4px;
}

#quarto-margin-sidebar::-webkit-scrollbar-track {
  background: transparent;
}

</style>

  


</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="99">
    <h2 id="toc-title"><strong>Table of contents</strong></h2>
   
  <ul>
  <li><a href="#initialization" id="toc-initialization" class="nav-link active" data-scroll-target="#initialization"><span class="header-section-number">1</span> Initialization</a>
  <ul>
  <li><a href="#importing-libraries-and-datasets" id="toc-importing-libraries-and-datasets" class="nav-link" data-scroll-target="#importing-libraries-and-datasets"><span class="header-section-number">1.1</span> <strong>Importing Libraries and datasets</strong></a></li>
  <li><a href="#understanding-the-data-by-viewing-a-few-observations" id="toc-understanding-the-data-by-viewing-a-few-observations" class="nav-link" data-scroll-target="#understanding-the-data-by-viewing-a-few-observations"><span class="header-section-number">1.2</span> <strong>Understanding the data by viewing a few observations</strong></a></li>
  <li><a href="#let-us-check-the-data-types-and-and-missing-values-of-each-column" id="toc-let-us-check-the-data-types-and-and-missing-values-of-each-column" class="nav-link" data-scroll-target="#let-us-check-the-data-types-and-and-missing-values-of-each-column"><span class="header-section-number">1.3</span> <strong>Let us check the data types and and missing values of each column</strong></a>
  <ul>
  <li><a href="#the-count-data-contains" id="toc-the-count-data-contains" class="nav-link" data-scroll-target="#the-count-data-contains"><span class="header-section-number">1.3.1</span> <strong>The count data contains:</strong></a></li>
  <li><a href="#the-song-data-contains" id="toc-the-song-data-contains" class="nav-link" data-scroll-target="#the-song-data-contains"><span class="header-section-number">1.3.2</span> <strong>The song data contains:</strong></a></li>
  </ul></li>
  </ul></li>
  <li><a href="#exploratory-data-analysis" id="toc-exploratory-data-analysis" class="nav-link" data-scroll-target="#exploratory-data-analysis"><span class="header-section-number">2</span> <strong>Exploratory Data Analysis</strong></a>
  <ul>
  <li><a href="#lets-check-the-total-number-of-unique-users-songs-artists-in-the-data" id="toc-lets-check-the-total-number-of-unique-users-songs-artists-in-the-data" class="nav-link" data-scroll-target="#lets-check-the-total-number-of-unique-users-songs-artists-in-the-data"><span class="header-section-number">2.1</span> <strong>Let’s check the total number of unique users, songs, artists in the data</strong></a>
  <ul>
  <li><a href="#the-data-contains" id="toc-the-data-contains" class="nav-link" data-scroll-target="#the-data-contains"><span class="header-section-number">2.1.1</span> <strong>The data contains :</strong></a></li>
  <li><a href="#as-per-the-number-of-unique-users-and-songs-there-is-a-possibility-of-3155-563-1.776.265-interactions-in-the-dataset.-but-we-only-have-117.876-interactions-meeting-our-criterias90-songs-count-per-user-120-users-count-per-song-and-at-most-5-play-counts-per-song-i.e.-not-every-user-has-listened-every-song-in-the-dataset-which-is-quite-understandable.this-creates-the-possibility-of-building-a-recommendation-system-to-recommend-products-to-the-users-which-they-have-not-interacted-with." id="toc-as-per-the-number-of-unique-users-and-songs-there-is-a-possibility-of-3155-563-1.776.265-interactions-in-the-dataset.-but-we-only-have-117.876-interactions-meeting-our-criterias90-songs-count-per-user-120-users-count-per-song-and-at-most-5-play-counts-per-song-i.e.-not-every-user-has-listened-every-song-in-the-dataset-which-is-quite-understandable.this-creates-the-possibility-of-building-a-recommendation-system-to-recommend-products-to-the-users-which-they-have-not-interacted-with." class="nav-link" data-scroll-target="#as-per-the-number-of-unique-users-and-songs-there-is-a-possibility-of-3155-563-1.776.265-interactions-in-the-dataset.-but-we-only-have-117.876-interactions-meeting-our-criterias90-songs-count-per-user-120-users-count-per-song-and-at-most-5-play-counts-per-song-i.e.-not-every-user-has-listened-every-song-in-the-dataset-which-is-quite-understandable.this-creates-the-possibility-of-building-a-recommendation-system-to-recommend-products-to-the-users-which-they-have-not-interacted-with."><span class="header-section-number">2.1.2</span> As per the number of unique users and songs, there is a possibility of 3155 * 563 = <strong>1.776.265 interactions in the dataset</strong>. But we only have <strong>117.876 interactions</strong> meeting our criterias(90 songs count per user, 120 users count per song and at most 5 play counts per song), i.e., <strong>not every user has listened every song</strong> in the dataset, which is quite understandable.This creates the <strong>possibility of building a recommendation system to recommend products to the users which they have not interacted with</strong>.</a></li>
  </ul></li>
  <li><a href="#lets-find-out-about-the-most-interacted-songs-and-interacted-users" id="toc-lets-find-out-about-the-most-interacted-songs-and-interacted-users" class="nav-link" data-scroll-target="#lets-find-out-about-the-most-interacted-songs-and-interacted-users"><span class="header-section-number">2.2</span> <strong>Let’s find out about the most interacted songs and interacted users</strong></a>
  <ul>
  <li><a href="#the-top-user-and-song-are-the-user-with-id-2548-and-the-song-with-id-8581" id="toc-the-top-user-and-song-are-the-user-with-id-2548-and-the-song-with-id-8581" class="nav-link" data-scroll-target="#the-top-user-and-song-are-the-user-with-id-2548-and-the-song-with-id-8581"><span class="header-section-number">2.2.1</span> <strong>The top user and song are the user with id 2548 and the song with id 8581</strong></a></li>
  <li><a href="#the-number-of-titles-played-can-be-segmented-into-3-groups.-the-groups-are-created-below-by-dividing-the-year-colonne-into-3-segments" id="toc-the-number-of-titles-played-can-be-segmented-into-3-groups.-the-groups-are-created-below-by-dividing-the-year-colonne-into-3-segments" class="nav-link" data-scroll-target="#the-number-of-titles-played-can-be-segmented-into-3-groups.-the-groups-are-created-below-by-dividing-the-year-colonne-into-3-segments"><span class="header-section-number">2.2.2</span> <strong>The number of titles played can be segmented into 3 groups.</strong> The groups are created below by dividing the year colonne into 3 segments:</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#building-various-models" id="toc-building-various-models" class="nav-link" data-scroll-target="#building-various-models"><span class="header-section-number">3</span> Building various models</a>
  <ul>
  <li><a href="#popularity-based-recommendation-systems" id="toc-popularity-based-recommendation-systems" class="nav-link" data-scroll-target="#popularity-based-recommendation-systems"><span class="header-section-number">3.1</span> <strong>Popularity-Based Recommendation Systems</strong></a></li>
  <li><a href="#user-user-similarity-based-collaborative-filtering" id="toc-user-user-similarity-based-collaborative-filtering" class="nav-link" data-scroll-target="#user-user-similarity-based-collaborative-filtering"><span class="header-section-number">3.2</span> <strong>User User Similarity-Based Collaborative Filtering</strong></a></li>
  <li><a href="#some-useful-functions" id="toc-some-useful-functions" class="nav-link" data-scroll-target="#some-useful-functions"><span class="header-section-number">3.3</span> Some useful functions</a></li>
  <li><a href="#correcting-the-play_counts-and-ranking-the-above-songs" id="toc-correcting-the-play_counts-and-ranking-the-above-songs" class="nav-link" data-scroll-target="#correcting-the-play_counts-and-ranking-the-above-songs"><span class="header-section-number">3.4</span> Correcting the play_counts and Ranking the above songs</a></li>
  <li><a href="#item-item-similarity-based-collaborative-filtering-recommendation-systems" id="toc-item-item-similarity-based-collaborative-filtering-recommendation-systems" class="nav-link" data-scroll-target="#item-item-similarity-based-collaborative-filtering-recommendation-systems"><span class="header-section-number">3.5</span> Item Item Similarity-based collaborative filtering recommendation systems</a></li>
  <li><a href="#model-based-collaborative-filtering---matrix-factorization" id="toc-model-based-collaborative-filtering---matrix-factorization" class="nav-link" data-scroll-target="#model-based-collaborative-filtering---matrix-factorization"><span class="header-section-number">3.6</span> Model Based Collaborative Filtering - Matrix Factorization</a>
  <ul>
  <li><a href="#improving-matrix-factorization-based-recommendation-system-by-tuning-its-hyperparameters" id="toc-improving-matrix-factorization-based-recommendation-system-by-tuning-its-hyperparameters" class="nav-link" data-scroll-target="#improving-matrix-factorization-based-recommendation-system-by-tuning-its-hyperparameters"><span class="header-section-number">3.6.1</span> Improving matrix factorization based recommendation system by tuning its hyperparameters</a></li>
  </ul></li>
  <li><a href="#cluster-based-recommendation-system" id="toc-cluster-based-recommendation-system" class="nav-link" data-scroll-target="#cluster-based-recommendation-system"><span class="header-section-number">3.7</span> Cluster Based Recommendation System</a>
  <ul>
  <li><a href="#improving-clustering-based-recommendation-system-by-tuning-its-hyper-parameters" id="toc-improving-clustering-based-recommendation-system-by-tuning-its-hyper-parameters" class="nav-link" data-scroll-target="#improving-clustering-based-recommendation-system-by-tuning-its-hyper-parameters"><span class="header-section-number">3.7.1</span> Improving clustering-based recommendation system by tuning its hyper-parameters</a></li>
  <li><a href="#implementing-the-recommendation-algorithm-based-on-optimized-coclustering-model" id="toc-implementing-the-recommendation-algorithm-based-on-optimized-coclustering-model" class="nav-link" data-scroll-target="#implementing-the-recommendation-algorithm-based-on-optimized-coclustering-model"><span class="header-section-number">3.7.2</span> Implementing the recommendation algorithm based on optimized CoClustering model</a></li>
  </ul></li>
  <li><a href="#correcting-the-play_count-and-ranking-the-above-songs" id="toc-correcting-the-play_count-and-ranking-the-above-songs" class="nav-link" data-scroll-target="#correcting-the-play_count-and-ranking-the-above-songs"><span class="header-section-number">3.8</span> Correcting the play_count and Ranking the above songs</a></li>
  <li><a href="#content-based-recommendation-systems" id="toc-content-based-recommendation-systems" class="nav-link" data-scroll-target="#content-based-recommendation-systems"><span class="header-section-number">3.9</span> Content Based Recommendation Systems</a></li>
  </ul></li>
  <li><a href="#conclusion-and-recommendations" id="toc-conclusion-and-recommendations" class="nav-link" data-scroll-target="#conclusion-and-recommendations"><span class="header-section-number">4</span> <strong>Conclusion and Recommendations</strong></a></li>
  <li><a href="#further-analysis" id="toc-further-analysis" class="nav-link" data-scroll-target="#further-analysis"><span class="header-section-number">5</span> <strong>Further analysis</strong></a></li>
  <li><a href="#tuning-the-model" id="toc-tuning-the-model" class="nav-link" data-scroll-target="#tuning-the-model"><span class="header-section-number">6</span> Tuning the model</a></li>
  <li><a href="#balancing-the-data" id="toc-balancing-the-data" class="nav-link" data-scroll-target="#balancing-the-data"><span class="header-section-number">7</span> Balancing the data</a></li>
  <li><a href="#examining-where-the-model-is-not-performing-well" id="toc-examining-where-the-model-is-not-performing-well" class="nav-link" data-scroll-target="#examining-where-the-model-is-not-performing-well"><span class="header-section-number">8</span> Examining where the model is not performing well</a></li>
  <li><a href="#customizing-the-knnbasic-algorithm" id="toc-customizing-the-knnbasic-algorithm" class="nav-link" data-scroll-target="#customizing-the-knnbasic-algorithm"><span class="header-section-number">9</span> Customizing the KNNBasic algorithm</a></li>
  <li><a href="#building-an-hybrid-recommendation-system" id="toc-building-an-hybrid-recommendation-system" class="nav-link" data-scroll-target="#building-an-hybrid-recommendation-system"><span class="header-section-number">10</span> Building an hybrid recommendation system:</a>
  <ul>
  <li><a href="#lets-evaluate-the-performance-of-the-model-with-a-threshold-in-surprise-library-manner" id="toc-lets-evaluate-the-performance-of-the-model-with-a-threshold-in-surprise-library-manner" class="nav-link" data-scroll-target="#lets-evaluate-the-performance-of-the-model-with-a-threshold-in-surprise-library-manner"><span class="header-section-number">10.1</span> Let’s evaluate the performance of the model with a threshold in Surprise library manner</a></li>
  <li><a href="#rebuilidng-the-model-by-transforming-the-item-features-with-a-vectorizer" id="toc-rebuilidng-the-model-by-transforming-the-item-features-with-a-vectorizer" class="nav-link" data-scroll-target="#rebuilidng-the-model-by-transforming-the-item-features-with-a-vectorizer"><span class="header-section-number">10.2</span> Rebuilidng the model by transforming the item features with a vectorizer</a></li>
  </ul></li>
  <li><a href="#final-conclusion" id="toc-final-conclusion" class="nav-link" data-scroll-target="#final-conclusion"><span class="header-section-number">11</span> Final Conclusion</a></li>
  </ul>
</nav>
</div>
<main class="content column-page-left" id="quarto-document-content">




<section id="initialization" class="level2" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="initialization"><span class="header-section-number">1</span> Initialization</h2>
<section id="importing-libraries-and-datasets" class="level3" data-number="1.1">
<h3 data-number="1.1" class="anchored" data-anchor-id="importing-libraries-and-datasets"><span class="header-section-number">1.1</span> <strong>Importing Libraries and datasets</strong></h3>
<div id="8a515a61" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Mounting the drive</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> google.colab <span class="im">import</span> drive</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>drive.mount(<span class="st">'/content/drive'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="469d4d19" class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Used to ignore the warning given as output of the code</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> warnings</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>warnings.filterwarnings(<span class="st">'ignore'</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Basic libraries of python for numeric and dataframe computations</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Import Matplotlib the Basic library for data visualization</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Import seaborn - Slightly advanced library for data visualization</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn <span class="im">as</span> sns</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Import the required library to compute the cosine similarity between two vectors</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics.pairwise <span class="im">import</span> cosine_similarity</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Import defaultdict from collections A dictionary output that does not raise a key error</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Impoort mean_squared_error : a performance metrics in sklearn</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics <span class="im">import</span> mean_squared_error</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="779fa04a" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Importing the datasets</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>song_df <span class="op">=</span> pd.read_csv(<span class="st">'/content/drive/MyDrive/capstone/song_data.csv'</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>count_df <span class="op">=</span> pd.read_csv(<span class="st">'/content/drive/MyDrive/capstone/count_data.csv'</span>,</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>                     usecols<span class="op">=</span>[<span class="st">'user_id'</span>,<span class="st">'song_id'</span>,<span class="st">'play_count'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="understanding-the-data-by-viewing-a-few-observations" class="level3" data-number="1.2">
<h3 data-number="1.2" class="anchored" data-anchor-id="understanding-the-data-by-viewing-a-few-observations"><span class="header-section-number">1.2</span> <strong>Understanding the data by viewing a few observations</strong></h3>
<div id="8810fc6a" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display first 10 records of count_df data</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>count_df.head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e5008b73" class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display first 10 records of song_df data</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>song_df.head(<span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="let-us-check-the-data-types-and-and-missing-values-of-each-column" class="level3" data-number="1.3">
<h3 data-number="1.3" class="anchored" data-anchor-id="let-us-check-the-data-types-and-and-missing-values-of-each-column"><span class="header-section-number">1.3</span> <strong>Let us check the data types and and missing values of each column</strong></h3>
<div id="0817d665" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display info of count_df</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>count_df.info(show_counts<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b3f0d9de" class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display info of song_df</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>song_df.info()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="the-count-data-contains" class="level4" data-number="1.3.1">
<h4 data-number="1.3.1" class="anchored" data-anchor-id="the-count-data-contains"><span class="header-section-number">1.3.1</span> <strong>The count data contains:</strong></h4>
<ul>
<li><strong>2000000 observations</strong> and <strong>3 columns</strong>.</li>
<li><strong>user_id</strong> and <strong>sond_id</strong> columns are of <strong>object data type</strong> but <strong>play_count</strong> column is of <strong>numeric data type</strong>.</li>
<li>There is <strong>no missing value</strong>.</li>
</ul>
</section>
<section id="the-song-data-contains" class="level4" data-number="1.3.2">
<h4 data-number="1.3.2" class="anchored" data-anchor-id="the-song-data-contains"><span class="header-section-number">1.3.2</span> <strong>The song data contains:</strong></h4>
<ul>
<li><strong>1000000 observations</strong> and <strong>5 columns</strong>.</li>
<li><strong>All the columns</strong> are of <strong>object data type</strong> except the year column. The <strong>year column</strong> is of <strong>numeric data type</strong>.</li>
<li>The <strong>title</strong> and <strong>release</strong> columns contains 1000000 - 999983 = <strong>17 null values</strong>. All the other columns do not contain null values.</li>
</ul>
<div id="c1bd9e0f" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Left merge count_df and song_df on "song_id". Drop duplicates from song_df data simultaneously</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.merge(count_df, song_df.drop_duplicates(<span class="st">'song_id'</span>), how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop the column 'Unnamed: 0'</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Already droped while loading the dataset</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Name the obtained dataframe as "df"</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Already named df</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Think About It:</strong> As the user_id and song_id are encrypted. Can they be encoded to numeric features? - <strong>Yes</strong>, in this case encoding categorical feature <strong>increase the execution performance</strong> of the models although it does not impact the qualiy of the predictions</p>
<div id="f9a59747" class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply label encoding for "user_id" and "song_id"</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> LabelEncoder</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co">#saving the original df in df_copy</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>df_copy <span class="op">=</span> df.copy()</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co">#storing transformers in a dictionnary for decoding if needed</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>label_object <span class="op">=</span> {}</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>categorical_columns <span class="op">=</span> [<span class="st">'user_id'</span>,<span class="st">'song_id'</span>]</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> categorical_columns:</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>  labelencoder <span class="op">=</span> LabelEncoder()</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>  labelencoder.fit(df[col])</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>  df[col] <span class="op">=</span> labelencoder.fit_transform(df[col])</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>  label_object[col] <span class="op">=</span> labelencoder</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Think About It:</strong> As the data also contains users who have listened to very few songs and vice versa, is it required to filter the data so that it contains users who have listened to a good count of songs and vice versa? - <strong>Yes</strong>, filtering the data will indeed <strong>reduce the sparcity</strong> in the matrices used for modelling. Hence <strong>increasing the performance of the computation</strong> as well as the <strong>quality of the recommendations</strong></p>
<p>A dataset of size 2000000 rows x 7 columns can be quite large and may require a lot of computing resources to process. This can lead to long processing times and can make it difficult to train and evaluate your model efficiently. In order to address this issue, it may be necessary to trim down your dataset to a more manageable size.</p>
<div id="92bfda9b" class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the column containing the users</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>users <span class="op">=</span> df.user_id</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dictionary that maps users(listeners) to the number of songs that they have listened to</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>playing_count <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> user <span class="kw">in</span> users:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we already have the user, just add 1 to their playing count</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> user <span class="kw">in</span> playing_count:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        playing_count[user] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Otherwise, set their playing count to 1</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        playing_count[user] <span class="op">=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="69acfc0e" class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We want our users to have listened at least 90 songs</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>SONG_COUNT_CUTOFF <span class="op">=</span> <span class="dv">90</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a list of users who need to be removed</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>remove_users <span class="op">=</span> []</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> user, num_songs <span class="kw">in</span> playing_count.items():</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_songs <span class="op">&lt;</span> SONG_COUNT_CUTOFF:</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        remove_users.append(user)</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.loc[ <span class="op">~</span> df.user_id.isin(remove_users)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2d19b93b" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the column containing the songs</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>songs <span class="op">=</span> df.song_id</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dictionary that maps songs to its number of users(listeners)</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>playing_count <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> song <span class="kw">in</span> songs:</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we already have the song, just add 1 to their playing count</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> song <span class="kw">in</span> playing_count:</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        playing_count[song] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Otherwise, set their playing count to 1</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        playing_count[song] <span class="op">=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ec338792" class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We want our song to be listened by at least 120 users to be considred</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>LISTENER_COUNT_CUTOFF <span class="op">=</span> <span class="dv">120</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>remove_songs <span class="op">=</span> []</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> song, num_users <span class="kw">in</span> playing_count.items():</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_users <span class="op">&lt;</span> LISTENER_COUNT_CUTOFF:</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        remove_songs.append(song)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>df_final <span class="op">=</span> df.loc[ <span class="op">~</span> df.song_id.isin(remove_songs)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Out of all the songs available, songs with play_count less than or equal to 5 are in almost 90% abundance. So for building the recommendation system let us consider only those songs.</p>
<div id="0a292eb7" class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Keep only records of songs with play_count less than or equal to (&lt;=) 5</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>df_final <span class="op">=</span> df_final[df_final.play_count<span class="op">&lt;=</span><span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="eb6600ad" class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the shape of the data</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>df_final.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="exploratory-data-analysis" class="level2" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="exploratory-data-analysis"><span class="header-section-number">2</span> <strong>Exploratory Data Analysis</strong></h2>
<section id="lets-check-the-total-number-of-unique-users-songs-artists-in-the-data" class="level3" data-number="2.1">
<h3 data-number="2.1" class="anchored" data-anchor-id="lets-check-the-total-number-of-unique-users-songs-artists-in-the-data"><span class="header-section-number">2.1</span> <strong>Let’s check the total number of unique users, songs, artists in the data</strong></h3>
<p>Total number of unique user id</p>
<div id="27ff107d" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display total number of unique user_id</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>df_final.user_id.nunique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Total number of unique song id</p>
<div id="61ac0983" class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display total number of unique song_id</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>df_final.song_id.nunique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Total number of unique artists</p>
<div id="4ca801f6" class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Display total number of unique artists</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>df_final.artist_name.nunique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="the-data-contains" class="level4" data-number="2.1.1">
<h4 data-number="2.1.1" class="anchored" data-anchor-id="the-data-contains"><span class="header-section-number">2.1.1</span> <strong>The data contains :</strong></h4>
<ul>
<li><strong>117876</strong> observations</li>
<li><strong>3155</strong> unique users</li>
<li><strong>563</strong> unique songs</li>
</ul>
</section>
<section id="as-per-the-number-of-unique-users-and-songs-there-is-a-possibility-of-3155-563-1.776.265-interactions-in-the-dataset.-but-we-only-have-117.876-interactions-meeting-our-criterias90-songs-count-per-user-120-users-count-per-song-and-at-most-5-play-counts-per-song-i.e.-not-every-user-has-listened-every-song-in-the-dataset-which-is-quite-understandable.this-creates-the-possibility-of-building-a-recommendation-system-to-recommend-products-to-the-users-which-they-have-not-interacted-with." class="level4" data-number="2.1.2">
<h4 data-number="2.1.2" class="anchored" data-anchor-id="as-per-the-number-of-unique-users-and-songs-there-is-a-possibility-of-3155-563-1.776.265-interactions-in-the-dataset.-but-we-only-have-117.876-interactions-meeting-our-criterias90-songs-count-per-user-120-users-count-per-song-and-at-most-5-play-counts-per-song-i.e.-not-every-user-has-listened-every-song-in-the-dataset-which-is-quite-understandable.this-creates-the-possibility-of-building-a-recommendation-system-to-recommend-products-to-the-users-which-they-have-not-interacted-with."><span class="header-section-number">2.1.2</span> As per the number of unique users and songs, there is a possibility of 3155 * 563 = <strong>1.776.265 interactions in the dataset</strong>. But we only have <strong>117.876 interactions</strong> meeting our criterias(90 songs count per user, 120 users count per song and at most 5 play counts per song), i.e., <strong>not every user has listened every song</strong> in the dataset, which is quite understandable.This creates the <strong>possibility of building a recommendation system to recommend products to the users which they have not interacted with</strong>.</h4>
</section>
</section>
<section id="lets-find-out-about-the-most-interacted-songs-and-interacted-users" class="level3" data-number="2.2">
<h3 data-number="2.2" class="anchored" data-anchor-id="lets-find-out-about-the-most-interacted-songs-and-interacted-users"><span class="header-section-number">2.2</span> <strong>Let’s find out about the most interacted songs and interacted users</strong></h3>
<p>Most interacted songs</p>
<div id="3f239ac1" class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Printing the top ten songs</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>df_final.song_id.value_counts()[:<span class="dv">10</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Most interacted users</p>
<div id="8319905d" class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Printing the top ten users</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>df_final.user_id.value_counts()[:<span class="dv">10</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="the-top-user-and-song-are-the-user-with-id-2548-and-the-song-with-id-8581" class="level4" data-number="2.2.1">
<h4 data-number="2.2.1" class="anchored" data-anchor-id="the-top-user-and-song-are-the-user-with-id-2548-and-the-song-with-id-8581"><span class="header-section-number">2.2.1</span> <strong>The top user and song are the user with id 2548 and the song with id 8581</strong></h4>
<ul>
<li>The <strong>top user</strong> listened to <strong>243 songs</strong>
<ul>
<li>Since there are <strong>563 songs</strong>, it is <strong>possible to make recommations</strong> to this particular user and to all users in general. For this top user, there are 563 - 243 = <strong>320 possible recommendations left</strong>.</li>
</ul></li>
<li>The <strong>most popular song</strong> was listened to by <strong>751 users</strong>
<ul>
<li>Since there are <strong>3155 users</strong>, there are 3155 - 751 = <strong>2404 possible users left to whom we could recommend this song</strong>.</li>
</ul></li>
</ul>
<p>Songs released on yearly basis</p>
<div id="2c072813" class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Find out the number of songs released in a year, use the songs_df</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Hint: Use groupby function on the 'year' column</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>song_df.drop_duplicates(<span class="st">'song_id'</span>).groupby(<span class="st">'year'</span>).song_id.count().sort_values(ascending<span class="op">=</span><span class="va">False</span>)[:<span class="dv">10</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="72130b39" class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a barplot plot with y label as "number of titles played" and x -axis year</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>nbr_titles_played_by_year <span class="op">=</span> df_final.groupby(<span class="st">'year'</span>).title.nunique()</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">'ggplot'</span>)</span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the figure size</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">5</span>))</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">#from the previous cell, we could see there is an abnormal year 0, which seems to be</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">#a default, so we're dropping that year</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>plt.bar(x<span class="op">=</span>nbr_titles_played_by_year.index[<span class="dv">1</span>:], height<span class="op">=</span>nbr_titles_played_by_year[<span class="dv">1</span>:])</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the x label of the plot</span></span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'year'</span>)</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the y label of the plot</span></span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'number of titles played'</span>)</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting all the ticks</span></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>plt.xticks(ticks<span class="op">=</span>nbr_titles_played_by_year.index[<span class="dv">1</span>:], rotation<span class="op">=</span><span class="dv">90</span>, size<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="the-number-of-titles-played-can-be-segmented-into-3-groups.-the-groups-are-created-below-by-dividing-the-year-colonne-into-3-segments" class="level4" data-number="2.2.2">
<h4 data-number="2.2.2" class="anchored" data-anchor-id="the-number-of-titles-played-can-be-segmented-into-3-groups.-the-groups-are-created-below-by-dividing-the-year-colonne-into-3-segments"><span class="header-section-number">2.2.2</span> <strong>The number of titles played can be segmented into 3 groups.</strong> The groups are created below by dividing the year colonne into 3 segments:</h4>
<ul>
<li><strong>[1969 - 1983]</strong> : in this segment, the <strong>number of titles played is very low, less or equal to 2</strong>.</li>
<li><strong>[1986 - 1997]</strong> : in this segment, the <strong>number of titles played is less or equal to 7</strong>, 1991 having 7.</li>
<li><strong>[1999 - 2010]</strong> : in this segment, the <strong>number of titles played vary beetween 8 and 79</strong>, 1999 having the lowest and 2007 having the maximum.</li>
</ul>
<p><strong>Think About It:</strong> What other insights can be drawn using exploratory data analysis? - We can also <strong>visualize the distribution of the play counts:</strong></p>
<div id="7717ef9a" class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> df_final</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>sns.countplot(data<span class="op">=</span>data, x<span class="op">=</span>data.play_count, hue<span class="op">=</span><span class="st">'play_count'</span>, palette<span class="op">=</span><span class="st">'dark'</span>,</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>              legend<span class="op">=</span><span class="va">False</span>, stat<span class="op">=</span><span class="st">'proportion'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>From the above figure, we can see: - <strong>most of the songs, 60 percent</strong> have been played only once and - <strong>80 percent of the songs</strong> have been <strong>played less than 3 times</strong>.</p>
<p>Now that we have explored the data, let’s apply different algorithms to build recommendation systems.</p>
<p><strong>Note:</strong> Use the shorter version of the data, i.e., the data after the cutoffs as used in Milestone 1.</p>
</section>
</section>
</section>
<section id="building-various-models" class="level2" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="building-various-models"><span class="header-section-number">3</span> Building various models</h2>
<section id="popularity-based-recommendation-systems" class="level3" data-number="3.1">
<h3 data-number="3.1" class="anchored" data-anchor-id="popularity-based-recommendation-systems"><span class="header-section-number">3.1</span> <strong>Popularity-Based Recommendation Systems</strong></h3>
<p>Let’s take the count and sum of play counts of the songs and build the popularity recommendation systems based on the sum of play counts.</p>
<div id="d81e7627" class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculating average play_count</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Hint: Use groupby function on the song_id column</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>play_avg <span class="op">=</span> df_final.groupby(<span class="st">'song_id'</span>).play_count.mean()</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Calculating the frequency a song is played</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Hint: Use groupby function on the song_id column</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>play_freq <span class="op">=</span> <span class="dv">100</span> <span class="op">*</span> df_final.groupby(<span class="st">'song_id'</span>).play_count.<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="08253c7e" class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Making a dataframe with the average_count and play_freq</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>df_songs_count_freq <span class="op">=</span> pd.DataFrame({<span class="st">'play_avg'</span>:play_avg, <span class="st">'play_freq'</span>:play_freq})</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us see the first five records of the final_play dataset</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>df_songs_count_freq[:<span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now, let’s create a function to find the top n songs for a recommendation based on the average play count of song. We can also add a threshold for a minimum number of playcounts for a song to be considered for recommendation.</p>
<div id="038c8a2a" class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build the function to find top n songs</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> top_n_songs(df, n, min_playcount <span class="op">=</span> <span class="dv">50</span>):</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>  <span class="co">"""</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="co">  It gives top n songs among those being played for more than min_playcount</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">  """</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Finding products with minimum number of interactions</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a>  recommendations <span class="op">=</span> df[df.play_freq <span class="op">&gt;</span> min_playcount]</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sorting values with respect to average rating</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>  recommendations <span class="op">=</span> recommendations.sort_values(by<span class="op">=</span><span class="st">'play_avg'</span>, ascending<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">list</span>(recommendations.index[:n])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f83c08eb" class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Recommend top 10 songs using the function defined above</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>top_n_songs(df_songs_count_freq, <span class="dv">10</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="user-user-similarity-based-collaborative-filtering" class="level3" data-number="3.2">
<h3 data-number="3.2" class="anchored" data-anchor-id="user-user-similarity-based-collaborative-filtering"><span class="header-section-number">3.2</span> <strong>User User Similarity-Based Collaborative Filtering</strong></h3>
<p>To build the user-user-similarity-based and subsequent models we will use the “surprise” library.</p>
<div id="27782cd8" class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Install the surprise package using pip. Uncomment and run the below code to do the same</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install surprise</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="3cd95603" class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Import necessary libraries</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise <span class="im">import</span> similarities</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.metrics.pairwise <span class="im">import</span> cosine_similarity</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="co"># To compute the accuracy of models</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise <span class="im">import</span> accuracy</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="co"># This class is used to parse a file containing play_counts, data should be in structure - user; item; play_count</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.reader <span class="im">import</span> Reader</span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Class for loading datasets</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.dataset <span class="im">import</span> Dataset</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="co"># For tuning model hyperparameters</span></span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.model_selection <span class="im">import</span> GridSearchCV</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="co"># For splitting the data in train and test dataset</span></span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.model_selection <span class="im">import</span> train_test_split</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a><span class="co"># For implementing similarity-based recommendation system</span></span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.prediction_algorithms.knns <span class="im">import</span> KNNBasic</span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a><span class="co"># For implementing matrix factorization based recommendation system</span></span>
<span id="cb29-29"><a href="#cb29-29" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.prediction_algorithms.matrix_factorization <span class="im">import</span> SVD</span>
<span id="cb29-30"><a href="#cb29-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-31"><a href="#cb29-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-32"><a href="#cb29-32" aria-hidden="true" tabindex="-1"></a><span class="co"># For implementing KFold cross-validation</span></span>
<span id="cb29-33"><a href="#cb29-33" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.model_selection <span class="im">import</span> KFold</span>
<span id="cb29-34"><a href="#cb29-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-35"><a href="#cb29-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-36"><a href="#cb29-36" aria-hidden="true" tabindex="-1"></a><span class="co"># For implementing clustering-based recommendation system</span></span>
<span id="cb29-37"><a href="#cb29-37" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise <span class="im">import</span> CoClustering</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="some-useful-functions" class="level3" data-number="3.3">
<h3 data-number="3.3" class="anchored" data-anchor-id="some-useful-functions"><span class="header-section-number">3.3</span> Some useful functions</h3>
<p>Below is the function to calculate precision@k and recall@k, RMSE, and F1_Score@k to evaluate the model performance.</p>
<p><strong>Think About It:</strong> Which metric should be used for this problem to compare different models?</p>
<div id="53321214" class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> precision_recall_at_k(model, k<span class="op">=</span><span class="dv">30</span>, threshold<span class="op">=</span><span class="fl">1.5</span>, testset<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Return precision and recall at k metrics for each user"""</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First map the predictions to each user.</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    user_est_true <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Making predictions on the test data</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    predictions <span class="op">=</span> model.test(testset)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> uid, _, true_r, est, _ <span class="kw">in</span> predictions:</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>        user_est_true[uid].append((est, true_r))</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    precisions <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a>    recalls <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> uid, playing_count <span class="kw">in</span> user_est_true.items():</span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sort play count by estimated value</span></span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true" tabindex="-1"></a>        playing_count.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Number of relevant items</span></span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true" tabindex="-1"></a>        n_rel <span class="op">=</span> <span class="bu">sum</span>((true_r <span class="op">&gt;=</span> threshold) <span class="cf">for</span> (_, true_r) <span class="kw">in</span> playing_count)</span>
<span id="cb30-23"><a href="#cb30-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-24"><a href="#cb30-24" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Number of recommended items in top k</span></span>
<span id="cb30-25"><a href="#cb30-25" aria-hidden="true" tabindex="-1"></a>        n_rec_k <span class="op">=</span> <span class="bu">sum</span>((est <span class="op">&gt;=</span> threshold) <span class="cf">for</span> (est, _) <span class="kw">in</span> playing_count[:k])</span>
<span id="cb30-26"><a href="#cb30-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-27"><a href="#cb30-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Number of relevant and recommended items in top k</span></span>
<span id="cb30-28"><a href="#cb30-28" aria-hidden="true" tabindex="-1"></a>        n_rel_and_rec_k <span class="op">=</span> <span class="bu">sum</span>(((true_r <span class="op">&gt;=</span> threshold) <span class="kw">and</span> (est <span class="op">&gt;=</span> threshold))</span>
<span id="cb30-29"><a href="#cb30-29" aria-hidden="true" tabindex="-1"></a>                              <span class="cf">for</span> (est, true_r) <span class="kw">in</span> playing_count[:k])</span>
<span id="cb30-30"><a href="#cb30-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-31"><a href="#cb30-31" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Precision@K: Proportion of recommended items that are relevant</span></span>
<span id="cb30-32"><a href="#cb30-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># When n_rec_k is 0, Precision is undefined. We here set Precision to 0 when n_rec_k is 0.</span></span>
<span id="cb30-33"><a href="#cb30-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-34"><a href="#cb30-34" aria-hidden="true" tabindex="-1"></a>        precisions[uid] <span class="op">=</span> n_rel_and_rec_k <span class="op">/</span> n_rec_k <span class="cf">if</span> n_rec_k <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb30-35"><a href="#cb30-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-36"><a href="#cb30-36" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Recall@K: Proportion of relevant items that are recommended</span></span>
<span id="cb30-37"><a href="#cb30-37" aria-hidden="true" tabindex="-1"></a>        <span class="co"># When n_rel is 0, Recall is undefined. We here set Recall to 0 when n_rel is 0.</span></span>
<span id="cb30-38"><a href="#cb30-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-39"><a href="#cb30-39" aria-hidden="true" tabindex="-1"></a>        recalls[uid] <span class="op">=</span> n_rel_and_rec_k <span class="op">/</span> n_rel <span class="cf">if</span> n_rel <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb30-40"><a href="#cb30-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-41"><a href="#cb30-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Mean of all the predicted precisions are calculated.</span></span>
<span id="cb30-42"><a href="#cb30-42" aria-hidden="true" tabindex="-1"></a>    precision <span class="op">=</span> <span class="bu">round</span>((<span class="bu">sum</span>(prec <span class="cf">for</span> prec <span class="kw">in</span> precisions.values()) <span class="op">/</span> <span class="bu">len</span>(precisions)),<span class="dv">3</span>)</span>
<span id="cb30-43"><a href="#cb30-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Mean of all the predicted recalls are calculated.</span></span>
<span id="cb30-44"><a href="#cb30-44" aria-hidden="true" tabindex="-1"></a>    recall <span class="op">=</span> <span class="bu">round</span>((<span class="bu">sum</span>(rec <span class="cf">for</span> rec <span class="kw">in</span> recalls.values()) <span class="op">/</span> <span class="bu">len</span>(recalls)),<span class="dv">3</span>)</span>
<span id="cb30-45"><a href="#cb30-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-46"><a href="#cb30-46" aria-hidden="true" tabindex="-1"></a>    accuracy.rmse(predictions)</span>
<span id="cb30-47"><a href="#cb30-47" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Precision: '</span>, precision) <span class="co">#Command to print the overall precision</span></span>
<span id="cb30-48"><a href="#cb30-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Recall: '</span>, recall) <span class="co">#Command to print the overall recall</span></span>
<span id="cb30-49"><a href="#cb30-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'F_1 score: '</span>, <span class="bu">round</span>((<span class="dv">2</span><span class="op">*</span>precision<span class="op">*</span>recall)<span class="op">/</span>(precision<span class="op">+</span>recall),<span class="dv">3</span>)) <span class="co"># Formula to compute the F-1 score.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Think About It:</strong> In the function precision_recall_at_k above the threshold value used is 1.5. How precision and recall are affected by changing the threshold? What is the intuition behind using the threshold value of 1.5? - Impact of the threshold on recall and precision - If we decrease the threshold, most of the predictions would be above the threshold, hence many of the items would be recommended. As the data is imbalanced (many low playcounts), The TP rate would increase and Precision and Recall would increase.<br>
- If we <strong>increase the threshold</strong>, most of the prediction would be below the threshold, hence few songs would be recommended. As the data is imbalanced (very few high playcounts), the TP rate would decrease. <strong>So Precision and Recall would decrease</strong>. - So a good threshold is a medium threshold but in the present case most of the predictions are around 1, so 1.5 is a good threshold. Moreover 1 playcount is not enough to say a user like a song. The higher the the threshold, the higher the likely hood the user would love the song.</p>
<ul>
<li><p>Evaluation parameters</p></li>
<li><p>To compute <strong>precision and recall</strong>, a <strong>threshold of 1.5 and k value of 30 will be considered for the recommended and relevant ratings</strong>.</p></li>
<li><p>Performance metrice selection</p></li>
<li><p>FP and FN costs are high in the present case. If the FP rate is high (precision is low), we recommend products that the user might not buy. And, if FN rate is high (recall is low) we fail to recommend relevant products that the user might purchase. Therefore, precision and recall need to be optimized. So the <strong>correct performance measure is the F_1 score</strong>.</p></li>
</ul>
<p>Below we are loading the <strong>dataset</strong>, which is a <strong>pandas dataframe</strong>, into a <strong>different format called <code>surprise.dataset.DatasetAutoFolds</code></strong> which is required by this library. To do this we will be <strong>using the classes <code>Reader</code> and <code>Dataset</code></strong></p>
<p>You will also notice here that we read the dataset by providing a scale of ratings. However, as you would know, we do not have ratings data of the songs. In this case, we are going to use play_count as a proxy for ratings with the assumption that the more the user listens to a song, the higher the chance that they like the song</p>
<div id="ec7b19e2" class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Instantiating Reader scale with expected rating scale</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a> <span class="co">#use rating scale (0, 5)</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>reader <span class="op">=</span> Reader(rating_scale<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">5</span>))</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Loading the dataset</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a> <span class="co"># Take only "user_id","song_id", and "play_count"</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> Dataset.load_from_df(df_final[[<span class="st">'user_id'</span>,    <span class="st">'song_id'</span>, <span class="st">'play_count'</span>]],</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>                            reader<span class="op">=</span>reader)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Splitting the data into train and test dataset</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a> <span class="co"># Take test_size = 0.4, random_state = 42</span></span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>trainset, testset <span class="op">=</span> train_test_split(data, test_size<span class="op">=</span><span class="fl">0.4</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Think About It:</strong> How changing the test size would change the results and outputs?</p>
<p>As the data is imbalanced : - If we increase the test size, the performance of the model increase, as more diversity will appear in the testset - And conversely, if we decrease, the test size, the performance decrease.</p>
<div id="36ee06a5" class="cell" data-scrolled="false">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build the default user-user-similarity model</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>sim_options<span class="op">=</span><span class="bu">dict</span>(name<span class="op">=</span><span class="st">'cosine'</span>, user_based<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co"># KNN algorithm is used to find desired similar items</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use random_state = 1</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a>sim_user_user_model <span class="op">=</span> KNNBasic(sim_options<span class="op">=</span>sim_options, random_state<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>                               verbose<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the algorithm on the trainset, and predict play_count for the testset</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>sim_user_user_model.fit(trainset)</span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us compute precision@k, recall@k, and f_1 score with k = 30</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use sim_user_user model</span></span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(sim_user_user_model, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The F_1 score is not good, this is likely due to the imbalanced data. We need more observations.</p>
<div id="48b1ddf0" class="cell">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># selecting a sample user with a listened song, let's choose the first observation</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>user_id_interaction, song_id_interaction, play_count_interaction <span class="op">=</span> df_final[[<span class="st">'user_id'</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>, <span class="st">'song_id'</span>, <span class="st">'play_count'</span>]].iloc[<span class="dv">0</span>].values</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'user_id chosen is:'</span>, user_id_interaction,</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>      <span class="st">'</span><span class="ch">\n</span><span class="st">song_id chosen listened by the user is:'</span>, song_id_interaction,</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>      <span class="st">'</span><span class="ch">\n</span><span class="st">and the play count of this pair is:'</span>, play_count_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fe6fc0c8" class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predicting play_count for a sample user with a listened song</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Use any user id  and song_id</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>sim_user_user_model.predict(user_id_interaction, song_id_interaction, r_ui<span class="op">=</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="7b3dc3a0" class="cell">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to find the list of users who have not listened to the song song_id.</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> n_users_not_listened_song(n, data, song_id):</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    users_listened_song <span class="op">=</span> <span class="bu">set</span>(data[data[<span class="st">'song_id'</span>] <span class="op">==</span> song_id][<span class="st">'user_id'</span>])</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    all_users <span class="op">=</span> <span class="bu">set</span>(data[<span class="st">'user_id'</span>])</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># n is the number of elements to get in the list</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(all_users.difference(users_listened_song))[:n]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="60a77de8" class="cell">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Randomly choosing a song_id</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>song_id_no_interaction <span class="op">=</span> df_final.song_id.values[<span class="dv">10</span>]</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Finding a user who has not listened to the song</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>user_id_no_interaction <span class="op">=</span> n_users_not_listened_song(<span class="dv">1</span>, df_final,</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>                                                   song_id_no_interaction)[<span class="dv">0</span>]</span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'user_id chosen is:'</span>, user_id_no_interaction,</span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a>      <span class="st">'</span><span class="ch">\n</span><span class="st">song_id chosen and not listened by the user is:'</span>, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d03da97c" class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predicting play_count for a sample user with a song not-listened by the user</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a> <span class="co">#predict play_count for any sample user</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>sim_user_user_model.predict(user_id_no_interaction, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The predicted play count</strong> for the <strong>interacted user-song pair is 1.2</strong>. The <strong>actual play count is 1</strong>, so the prediction is pretty good.</p>
<p><strong>The predicted play count</strong> the for the <strong>user-song pair with no interaciton is 1.74</strong></p>
<p>Now, let’s try to tune the model and see if we can improve the model performance.</p>
<div id="6f3964f4" class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting up parameter grid to tune the hyperparameters</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>params_grid <span class="op">=</span> <span class="bu">dict</span>(k<span class="op">=</span>[<span class="dv">60</span>, <span class="dv">80</span>], min_k<span class="op">=</span>[<span class="dv">40</span>, <span class="dv">50</span>],</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>                   sim_options<span class="op">=</span><span class="bu">dict</span>(name<span class="op">=</span>[<span class="st">'msd'</span>, <span class="st">'cosine'</span>],</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">#min_support = [5, 10, 20],</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>                                    user_based<span class="op">=</span>[<span class="va">True</span>]))</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Performing 3-fold cross-validation to tune the hyperparameters</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>gs <span class="op">=</span> GridSearchCV(KNNBasic, param_grid<span class="op">=</span>params_grid, cv<span class="op">=</span><span class="dv">3</span>, measures<span class="op">=</span>[<span class="st">'rmse'</span>],</span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>                  n_jobs<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Fitting the data</span></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use entire data for GridSearch</span></span>
<span id="cb38-13"><a href="#cb38-13" aria-hidden="true" tabindex="-1"></a>gs.fit(data)</span>
<span id="cb38-14"><a href="#cb38-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-15"><a href="#cb38-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Best RMSE score</span></span>
<span id="cb38-16"><a href="#cb38-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best RMSE score:"</span>, gs.best_score[<span class="st">'rmse'</span>])</span>
<span id="cb38-17"><a href="#cb38-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-18"><a href="#cb38-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Combination of parameters that gave the best RMSE score</span></span>
<span id="cb38-19"><a href="#cb38-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best_params:"</span>, gs.best_params[<span class="st">'rmse'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="727ecb2f" class="cell">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the best model found in above gridsearch</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the optimal similarity measure for user-user based collaborative filtering</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>best_params <span class="op">=</span> gs.best_params[<span class="st">'rmse'</span>]</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>best_k <span class="op">=</span> best_params[<span class="st">'k'</span>]</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>best_min_k <span class="op">=</span> best_params[<span class="st">'min_k'</span>]</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>best_sim_options <span class="op">=</span> best_params[<span class="st">'sim_options'</span>]</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Creating an instance of KNNBasic with optimal hyperparameter values</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>sim_user_user_tuned_model <span class="op">=</span> KNNBasic(k <span class="op">=</span> best_k, min_k<span class="op">=</span>best_min_k,</span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>                                     sim_options<span class="op">=</span>best_sim_options,</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>                                     random_state<span class="op">=</span><span class="dv">1</span>, verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Training the algorithm on the trainset</span></span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>sim_user_user_tuned_model.fit(trainset)</span>
<span id="cb39-15"><a href="#cb39-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-16"><a href="#cb39-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us compute precision@k and recall@k also</span></span>
<span id="cb39-17"><a href="#cb39-17" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(sim_user_user_tuned_model, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The F1 score of this tuned model is 0.513. So it has silightly increased compared to the baseline model which was 0.504.</p>
<div id="c45eb597" class="cell">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict the play count for a user who has listened to the song. Take user_id 6958, song_id 1671 and r_ui = 2</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>user_id_interaction, song_id_interaction, play_count_interaction <span class="op">=</span> <span class="dv">6958</span>, <span class="dv">1671</span>, <span class="dv">2</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>sim_user_user_tuned_model.predict(user_id_interaction, song_id_interaction,</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>                                  r_ui <span class="op">=</span> play_count_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e6f17bce" class="cell">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function to find the list of songs who have not been listened by user_id.</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> n_songs_not_listened_user(n, data, user_id):</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    songs_listened_user <span class="op">=</span> <span class="bu">set</span>(data[data[<span class="st">'user_id'</span>] <span class="op">==</span> user_id][<span class="st">'song_id'</span>])</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    all_songs <span class="op">=</span> <span class="bu">set</span>(data[<span class="st">'song_id'</span>])</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># n is the number of elements to get in the list</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">list</span>(all_songs.difference(songs_listened_user))[:n]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6febc5e3" class="cell">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>user_id_no_interaction <span class="op">=</span> <span class="dv">6958</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Finding a song who has not been listened by the user above</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>song_id_no_interaction <span class="op">=</span> n_songs_not_listened_user(<span class="dv">1</span>, df_final, user_id_no_interaction)[<span class="dv">0</span>]</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'user_id chosen is:'</span>, user_id_no_interaction,</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>      <span class="st">'</span><span class="ch">\n</span><span class="st">song_id chosen and not listened by the user is:'</span>, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="29682f63" class="cell">
<div class="sourceCode cell-code" id="cb43"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Verifying that the user has not listened to the song</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>df_final.query(<span class="st">'user_id == @user_id_no_interaction &amp; song_id == @song_id_no_interaction'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="30d66463" class="cell">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict the play count for a song that is not listened to by the user (with user_id 6958)</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>sim_user_user_tuned_model.predict(user_id_no_interaction, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The predicted play count</strong> for the <strong>interacted user-song pair is 1.49</strong>. The <strong>actual play count is 2</strong>, so the prediction is far from the actual.</p>
<p><strong>The predicted play count</strong> the for the <strong>user-song pair with no interaciton is 1.53</strong></p>
<p><strong>Think About It:</strong> Along with making predictions on listened and unknown songs can we get 5 nearest neighbors (most similar) to a certain song? - Yes, we can get the list of the songs similar to a song</p>
<div id="87371354" class="cell">
<div class="sourceCode cell-code" id="cb45"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use inner id 0</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>sim_user_user_tuned_model.get_neighbors(iid<span class="op">=</span><span class="dv">0</span>, k<span class="op">=</span><span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Below we will be implementing a function where the input parameters are:</p>
<ul>
<li>data: A <strong>song</strong> dataset</li>
<li>user_id: A user-id <strong>against which we want the recommendations</strong></li>
<li>top_n: The <strong>number of songs we want to recommend</strong></li>
<li>algo: The algorithm we want to use <strong>for predicting the play_count</strong></li>
<li>The output of the function is a <strong>set of top_n items</strong> recommended for the given user_id based on the given algorithm</li>
</ul>
<div id="d9bdb16e" class="cell">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_recommendations(data, user_id, top_n, algo):</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Creating an empty list to store the recommended song ids</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>    recommendations <span class="op">=</span> []</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Creating an user item interactions matrix</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    user_item_interactions_matrix <span class="op">=</span> data.pivot(index <span class="op">=</span> <span class="st">'user_id'</span>,</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>                                               columns <span class="op">=</span> <span class="st">'song_id'</span>,</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>                                               values <span class="op">=</span> <span class="st">'play_count'</span>)</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>    user_songs <span class="op">=</span> user_item_interactions_matrix.loc[user_id]</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extracting those song ids which the user_id has not played yet</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>    non_played_songs <span class="op">=</span> user_songs[user_songs.isnull()].index.tolist()</span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Looping through each of the song ids which user_id has not interacted yet</span></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> song_id <span class="kw">in</span> non_played_songs:</span>
<span id="cb46-17"><a href="#cb46-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-18"><a href="#cb46-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Predicting the users for those non played song ids by this user</span></span>
<span id="cb46-19"><a href="#cb46-19" aria-hidden="true" tabindex="-1"></a>        est <span class="op">=</span> algo.predict(user_id, song_id).est</span>
<span id="cb46-20"><a href="#cb46-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-21"><a href="#cb46-21" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Appending the predicted play_counts</span></span>
<span id="cb46-22"><a href="#cb46-22" aria-hidden="true" tabindex="-1"></a>        recommendations.append((song_id, est))</span>
<span id="cb46-23"><a href="#cb46-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-24"><a href="#cb46-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sorting the predicted play_counts in descending order</span></span>
<span id="cb46-25"><a href="#cb46-25" aria-hidden="true" tabindex="-1"></a>    recommendations.sort(key <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb46-26"><a href="#cb46-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-27"><a href="#cb46-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Returing top n highest predicted play_count songs for this user</span></span>
<span id="cb46-28"><a href="#cb46-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> recommendations[:top_n]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d3f4b1f7" class="cell">
<div class="sourceCode cell-code" id="cb47"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Make top 5 recommendations for any user_id with a similarity-based recommendation engine</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>recommendations <span class="op">=</span> get_recommendations(df_final, user_id_interaction, <span class="dv">5</span>,</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>                                      sim_user_user_tuned_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="434c351a" class="cell">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Building the dataframe for above recommendations with columns "song_id" and "predicted_play_count"</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>recommendations_df <span class="op">=</span> pd.DataFrame(recommendations, columns<span class="op">=</span>[<span class="st">'song_id'</span>, <span class="st">'predicted_play_count'</span>])</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>recommendations_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Above we can see the list of the songs recommended by the user-user colaborative filtering model</strong>. - the top recommendation is the song 7224 with 2.93 play_counts. - the fith recommendation is the song 4831 with 2.34 playcounts. - all the recommended songs have a predicted playcounts greater than 2.</p>
</section>
<section id="correcting-the-play_counts-and-ranking-the-above-songs" class="level3" data-number="3.4">
<h3 data-number="3.4" class="anchored" data-anchor-id="correcting-the-play_counts-and-ranking-the-above-songs"><span class="header-section-number">3.4</span> Correcting the play_counts and Ranking the above songs</h3>
<div id="c2aca2cd" class="cell">
<div class="sourceCode cell-code" id="cb49"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> ranking_songs(recommendations, playing_count):</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sort the songs based on play counts</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  ranked_songs <span class="op">=</span> playing_count.loc[[items[<span class="dv">0</span>] <span class="cf">for</span> items <span class="kw">in</span> recommendations]].sort_values(<span class="st">'play_freq'</span>, ascending <span class="op">=</span> <span class="va">False</span>)[[<span class="st">'play_freq'</span>]].reset_index()</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Merge with the recommended songs to get predicted play_counts</span></span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  ranked_songs <span class="op">=</span> ranked_songs.merge(pd.DataFrame(recommendations, columns <span class="op">=</span> [<span class="st">'song_id'</span>, <span class="st">'predicted_play_count'</span>]), on <span class="op">=</span> <span class="st">'song_id'</span>, how <span class="op">=</span> <span class="st">'inner'</span>)</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Rank the songs based on corrected play_counts</span></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>  ranked_songs[<span class="st">'corrected_play_count'</span>] <span class="op">=</span> ranked_songs[<span class="st">'predicted_play_count'</span>] <span class="op">-</span> <span class="dv">1</span> <span class="op">/</span> np.sqrt(ranked_songs[<span class="st">'play_freq'</span>])</span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Sort the songs based on corrected play_counts</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>  ranked_songs <span class="op">=</span> ranked_songs.sort_values(<span class="st">'corrected_play_count'</span>, ascending <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb49-13"><a href="#cb49-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-14"><a href="#cb49-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ranked_songs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Think About It:</strong> In the above function to correct the predicted play_count a quantity 1/np.sqrt(n) is subtracted. What is the intuition behind it? Is it also possible to add this quantity instead of subtracting? - we can correct the predictions of the songs by using the total play_count of the song. The intuition behind is the higher the playcount the higher the likely hood the song will be liked. So we can add the quantity 1/np.sqrt(n) to have optimistic predictions or in contrario we can substract that quantity to have play count below 5. - So the confidence interval of the predictions could be seen as : predicted_prediction - 1/np.sqrt(n), predicted_prediction + 1/np.sqrt(n)</p>
<div id="2e79c10a" class="cell">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Applying the ranking_songs function on the final_play data</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>ranking_songs(recommendations, df_songs_count_freq)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>As expected, the corrected play counts are slightly lower than the predicted ones</strong></p>
</section>
<section id="item-item-similarity-based-collaborative-filtering-recommendation-systems" class="level3" data-number="3.5">
<h3 data-number="3.5" class="anchored" data-anchor-id="item-item-similarity-based-collaborative-filtering-recommendation-systems"><span class="header-section-number">3.5</span> Item Item Similarity-based collaborative filtering recommendation systems</h3>
<div id="b9996ce0" class="cell" data-scrolled="false">
<div class="sourceCode cell-code" id="cb51"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply the item-item similarity collaborative filtering model with random_state = 1 and evaluate the model performance</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Declaring the similarity options</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>similarity_options <span class="op">=</span> <span class="bu">dict</span>(name<span class="op">=</span><span class="st">'cosine'</span>, user_based<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a><span class="co"># KNN algorithm is used to find desired similar items. Use random_state=1</span></span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a>sim_item_item_model <span class="op">=</span> KNNBasic(sim_options<span class="op">=</span>similarity_options,</span>
<span id="cb51-7"><a href="#cb51-7" aria-hidden="true" tabindex="-1"></a>                               random_state<span class="op">=</span><span class="dv">1</span>, verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb51-8"><a href="#cb51-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-9"><a href="#cb51-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the algorithm on the trainset, and predict ratings for the test set</span></span>
<span id="cb51-10"><a href="#cb51-10" aria-hidden="true" tabindex="-1"></a>sim_item_item_model.fit(trainset)</span>
<span id="cb51-11"><a href="#cb51-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-12"><a href="#cb51-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us compute precision@k, recall@k, and f_1 score</span></span>
<span id="cb51-13"><a href="#cb51-13" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(sim_item_item_model, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The F1 score of this basic item-item colaborative filtering model is 0.39</strong> - This is not a good score and is less than the F1 score of this basic user-user colaborative filtering model - So for this case, considering similar user seems to be better than considering similar items when building the model.</p>
<div id="7f0976ca" class="cell">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predicting play count for a sample user_id 6958 and song (with song_id 1671) listened to by the user</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>user_id_interaction, song_id_interaction, play_count_interaction <span class="op">=</span> <span class="dv">6958</span>, <span class="dv">1671</span>, <span class="dv">2</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>sim_item_item_model.predict(user_id_interaction, song_id_interaction,</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>                                  r_ui <span class="op">=</span> play_count_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fd520090" class="cell">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>song_id_no_interaction <span class="op">=</span> <span class="dv">1671</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Finding a user who has not listened to the song</span></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>user_id_no_interaction <span class="op">=</span> n_users_not_listened_song(<span class="dv">1</span>, df_final,</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>                                                   song_id_no_interaction)[<span class="dv">0</span>]</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'user_id chosen is:'</span>, user_id_no_interaction,</span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a>      <span class="st">'</span><span class="ch">\n</span><span class="st">song_id chosen and not listened by the user is:'</span>, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1cd209c6" class="cell">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict the play count for a user that has not listened to the song (with song_id 1671)</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>sim_item_item_model.predict(user_id_no_interaction, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The predicted play count</strong> for the <strong>interacted user-song pair is 1.36</strong>. The <strong>actual play count is 2</strong>, so the prediction is far from the actual. The number of neighbors available was <strong>20</strong>.</p>
<p><strong>The predicted play counts</strong> the for the <strong>user-song pair with no interaciton is 1.64.</strong></p>
<div id="26317794" class="cell">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply grid search for enhancing model performance</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting up parameter grid to tune the hyperparameters</span></span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>params_grid_item <span class="op">=</span> <span class="bu">dict</span>(k<span class="op">=</span>[<span class="dv">30</span>, <span class="dv">50</span>], min_k<span class="op">=</span>[<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">9</span>],</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>                   sim_options<span class="op">=</span><span class="bu">dict</span>(name<span class="op">=</span>[<span class="st">'cosine'</span>, <span class="st">'msd'</span>],</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>                                    min_support <span class="op">=</span> [<span class="dv">9</span>, <span class="dv">20</span>],</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>                                    user_based<span class="op">=</span>[<span class="va">False</span>]))</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Performing 3-fold cross-validation to tune the hyperparameters</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>gs <span class="op">=</span> GridSearchCV(KNNBasic, param_grid<span class="op">=</span>params_grid_item, cv<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>                  measures<span class="op">=</span>[<span class="st">'rmse'</span>], n_jobs<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Fitting the data</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>gs.fit(data)</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Find the best RMSE score</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best RMSE score:"</span>, gs.best_score[<span class="st">'rmse'</span>])</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract the combination of parameters that gave the best RMSE score</span></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"best_params:"</span>, gs.best_params[<span class="st">'rmse'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Think About It:</strong> How do the parameters affect the performance of the model? Can we improve the performance of the model further? Check the list of hyperparameters <a href="https://surprise.readthedocs.io/en/stable/knn_inspired.html">here</a>. - Choosing the right set of parameters is critical to some algorithms. - In this case, the similarity options and the number of neighbors enhance the performance of the models</p>
<div id="ecd9e148" class="cell">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply the best model found in the grid search</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the optimal similarity measure for item-item based collaborative filtering</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>best_params_item <span class="op">=</span> gs.best_params[<span class="st">'rmse'</span>]</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>best_k_item <span class="op">=</span> best_params_item[<span class="st">'k'</span>]</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>best_min_k_item <span class="op">=</span> best_params_item[<span class="st">'min_k'</span>]</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>best_sim_options_item <span class="op">=</span> best_params_item[<span class="st">'sim_options'</span>]</span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Creating an instance of KNNBasic with optimal hyperparameter values</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>sim_item_item_tuned_model <span class="op">=</span> KNNBasic(k <span class="op">=</span> best_k_item, min_k<span class="op">=</span>best_min_k_item,</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>                            sim_options<span class="op">=</span>best_sim_options_item, randm_state<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>                            verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Training the algorithm on the trainset</span></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>sim_item_item_tuned_model.fit(trainset)</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us compute precision@k and recall@k, f1_score and RMSE</span></span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(sim_item_item_tuned_model,  testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The performance has increased compared to the baseline item-item model:</strong> - The F1 score of this tuned model is 0.49 while the the F1 score of the baseline item-item model was 0.39. So the perfomance has increased by 0.1 points.</p>
<div id="254f5708" class="cell">
<div class="sourceCode cell-code" id="cb57"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predict the play_count by a user(user_id 6958) for the song (song_id 1671)</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>user_id_interaction, song_id_interaction, play_count_interaction <span class="op">=</span> <span class="dv">6958</span>, <span class="dv">1671</span>, <span class="dv">2</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>sim_item_item_tuned_model.predict(user_id_interaction, song_id_interaction,</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>                                  r_ui <span class="op">=</span> play_count_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d8e9a9d8" class="cell">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Predicting play count for a sample user_id 6958 with song_id 3232 which is not listened to by the user</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>user_id_no_interaction, song_id_no_interaction <span class="op">=</span> (<span class="dv">6958</span>, <span class="dv">3232</span>)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>sim_item_item_tuned_model.predict(user_id_no_interaction, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The predicted play count</strong> for the <strong>interacted user-song pair is 1.45</strong>. The <strong>actual play count is 2</strong>, so the prediction is far from the actual. The number of neighbors available was <strong>15</strong>.</p>
<p><strong>The predicted play count</strong> the for the <strong>user-song pair with no interaciton is 1.69.</strong></p>
<div id="05f0218f" class="cell">
<div class="sourceCode cell-code" id="cb59"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Find five most similar items to the item with inner id 0</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>sim_item_item_tuned_model.get_neighbors(iid<span class="op">=</span><span class="dv">0</span>, k<span class="op">=</span><span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="49d65080" class="cell">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Making top 5 recommendations for any user_id  with item_item_similarity-based recommendation engine</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>recommendations <span class="op">=</span> get_recommendations(df_final, user_id_interaction, <span class="dv">5</span>,</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>                                      sim_item_item_tuned_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b6651154" class="cell">
<div class="sourceCode cell-code" id="cb61"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Building the dataframe for above recommendations with columns "song_id" and "predicted_play_count"</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>recommendations_df <span class="op">=</span> pd.DataFrame(recommendations, columns<span class="op">=</span>[<span class="st">'song_id'</span>, <span class="st">'predicted_play_count'</span>])</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>recommendations_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="a4f957cb" class="cell">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Applying the ranking_songs function</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>ranking_songs(recommendations, df_songs_count_freq)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Above we can see the list of the songs recommended by the user-user colaborative filtering model</strong>. - The songs recommended by this model vary from the ones recommended by the user-user model - The predicted play counts vary beetwen 1.96 and 1.77</p>
</section>
<section id="model-based-collaborative-filtering---matrix-factorization" class="level3" data-number="3.6">
<h3 data-number="3.6" class="anchored" data-anchor-id="model-based-collaborative-filtering---matrix-factorization"><span class="header-section-number">3.6</span> Model Based Collaborative Filtering - Matrix Factorization</h3>
<p>Model-based Collaborative Filtering is a <strong>personalized recommendation system</strong>, the recommendations are based on the past behavior of the user and it is not dependent on any additional information. We use <strong>latent features</strong> to find recommendations for each user.</p>
<div id="bad063b0" class="cell">
<div class="sourceCode cell-code" id="cb63"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build baseline model using svd</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>svd <span class="op">=</span> SVD(random_state<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Training the algorithm on the trainset</span></span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a>svd.fit(trainset)</span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the function precision_recall_at_k to compute precision@k, recall@k, F1-Score, and RMSE</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(svd, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="67484ae7" class="cell">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Making prediction for user (with user_id 6958) to song (with song_id 1671), take r_ui = 2</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>user_id_interaction, song_id_interaction, play_count_interaction <span class="op">=</span> <span class="dv">6958</span>, <span class="dv">1671</span>, <span class="dv">2</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>svd.predict(user_id_interaction, song_id_interaction,</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>                                  r_ui <span class="op">=</span> play_count_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="37704324" class="cell">
<div class="sourceCode cell-code" id="cb65"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Making a prediction for the user who has not listened to the song (song_id 3232)</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>user_id_no_interaction, song_id_no_interaction <span class="op">=</span> (<span class="dv">6958</span>, <span class="dv">3232</span>)</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>svd.predict(user_id_no_interaction, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="improving-matrix-factorization-based-recommendation-system-by-tuning-its-hyperparameters" class="level4" data-number="3.6.1">
<h4 data-number="3.6.1" class="anchored" data-anchor-id="improving-matrix-factorization-based-recommendation-system-by-tuning-its-hyperparameters"><span class="header-section-number">3.6.1</span> Improving matrix factorization based recommendation system by tuning its hyperparameters</h4>
<div id="aa7d8b20" class="cell">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the parameter space to tune</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>params <span class="op">=</span> <span class="bu">dict</span>(n_epochs<span class="op">=</span>[<span class="dv">45</span>, <span class="dv">60</span>], lr_all<span class="op">=</span>[<span class="fl">0.0001</span>, <span class="fl">0.005</span>], reg_all<span class="op">=</span>[<span class="fl">0.05</span>, <span class="fl">0.1</span>],</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>              reg_bu<span class="op">=</span>[<span class="fl">0.05</span>, <span class="fl">0.1</span>])</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Performe 3-fold grid-search cross-validation</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>gs <span class="op">=</span> GridSearchCV(SVD, param_grid<span class="op">=</span>params, n_jobs<span class="op">=-</span><span class="dv">1</span>, measures<span class="op">=</span>[<span class="st">'rmse'</span>], cv<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Fitting data</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a>gs.fit(data)</span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Best RMSE score</span></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(gs.best_score[<span class="st">'rmse'</span>])</span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Combination of parameters that gave the best RMSE score</span></span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(gs.best_params[<span class="st">'rmse'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Think About It</strong>: How do the parameters affect the performance of the model? Can we improve the performance of the model further? Check the available hyperparameters <a href="https://surprise.readthedocs.io/en/stable/matrix_factorization.html">here</a>. - This svd algorithm has a lot of tunnable parameters. - Tweeking theses parameters might improve the predictions.</p>
<div id="c9a6c711" class="cell">
<div class="sourceCode cell-code" id="cb67"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Building the optimized SVD model using optimal hyperparameters</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>best_params_svd <span class="op">=</span> gs.best_params[<span class="st">'rmse'</span>]</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>best_n_epochs <span class="op">=</span> best_params_svd[<span class="st">'n_epochs'</span>]</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>best_lr <span class="op">=</span> best_params_svd[<span class="st">'lr_all'</span>]</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>best_reg <span class="op">=</span> best_params_svd[<span class="st">'reg_all'</span>]</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>best_reg_bu <span class="op">=</span> best_params_svd[<span class="st">'reg_bu'</span>]</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>svd_tuned <span class="op">=</span> SVD(n_epochs<span class="op">=</span>best_n_epochs, lr_all<span class="op">=</span>best_lr, reg_all<span class="op">=</span>best_reg,</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>                reg_bu<span class="op">=</span>best_reg_bu, random_state<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-11"><a href="#cb67-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the algorithm on the trainset</span></span>
<span id="cb67-12"><a href="#cb67-12" aria-hidden="true" tabindex="-1"></a>svd_tuned.fit(trainset)</span>
<span id="cb67-13"><a href="#cb67-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-14"><a href="#cb67-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the function precision_recall_at_k to compute precision@k, recall@k, F1-Score, and RMSE</span></span>
<span id="cb67-15"><a href="#cb67-15" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(svd_tuned, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The performance of this tuned model has not increased compared to the baseline svd model</p>
<div id="4a4b2e93" class="cell">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using svd_algo_optimized model to recommend for userId 6958 and song_id 1671</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>user_id_interaction, song_id_interaction, play_count_interaction <span class="op">=</span> <span class="dv">6958</span>, <span class="dv">1671</span>, <span class="dv">2</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a>svd_tuned.predict(user_id_interaction, song_id_interaction,</span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>                                  r_ui <span class="op">=</span> play_count_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="915e230a" class="cell">
<div class="sourceCode cell-code" id="cb69"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using svd_algo_optimized model to recommend for userId 6958 and song_id 3232 with unknown baseline play_count</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>user_id_no_interaction, song_id_no_interaction <span class="op">=</span> (<span class="dv">6958</span>, <span class="dv">3232</span>)</span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a>svd_tuned.predict(user_id_no_interaction, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The predicted play count</strong> for the <strong>interacted user-song pair is 1.48</strong>. The <strong>actual play count is 2</strong>, so the prediction is far from the actual.</p>
<p><strong>The predicted play count</strong> the for the <strong>user-song pair with no interaction is 1.54.</strong></p>
<div id="8a007517" class="cell">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Getting top 5 recommendations for user_id 6958 using "svd_optimized" algorithm</span></span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>recommendations <span class="op">=</span> get_recommendations(df_final, user_id_interaction, <span class="dv">5</span>,</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a>                                      sim_item_item_tuned_model)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="7416b77b" class="cell">
<div class="sourceCode cell-code" id="cb71"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ranking songs based on above recommendations</span></span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>recommendations_df <span class="op">=</span> pd.DataFrame(recommendations, columns<span class="op">=</span>[<span class="st">'song_id'</span>, <span class="st">'predicted_play_count'</span>])</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a>recommendations_df</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Above we can see the list of the songs recommended by the matrix factorization colaborative filtering model</strong>. - The songs recommended by this model are the ones recommended by the item-item model - The predicted play counts vary beetwen 1.96 and 1.77</p>
</section>
</section>
<section id="cluster-based-recommendation-system" class="level3" data-number="3.7">
<h3 data-number="3.7" class="anchored" data-anchor-id="cluster-based-recommendation-system"><span class="header-section-number">3.7</span> Cluster Based Recommendation System</h3>
<p>In <strong>clustering-based recommendation systems</strong>, we explore the <strong>similarities and differences</strong> in people’s tastes in songs based on how they rate different songs. We cluster similar users together and recommend songs to a user based on play_counts from other users in the same cluster.</p>
<div id="4057b4ed" class="cell">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Make baseline clustering model</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>clustering_model <span class="op">=</span> CoClustering(random_state<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the algorithm on the trainset</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>clustering_model.fit(trainset)</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the function precision_recall_at_k to compute precision@k, recall@k, F1-Score, and RMSE</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(clustering_model, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fcf49b76" class="cell">
<div class="sourceCode cell-code" id="cb73"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Making prediction for user_id 6958 and song_id 1671</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>user_id_interaction, song_id_interaction, play_count_interaction <span class="op">=</span> <span class="dv">6958</span>, <span class="dv">1671</span>, <span class="dv">2</span></span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>clustering_model.predict(user_id_interaction, song_id_interaction,</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>                                  r_ui <span class="op">=</span> play_count_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="80b15141" class="cell">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Making prediction for user (userid 6958) for a song(song_id 3232) not listened to by the user</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>user_id_no_interaction, song_id_no_interaction <span class="op">=</span> (<span class="dv">6958</span>, <span class="dv">3232</span>)</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>clustering_model.predict(user_id_no_interaction, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="improving-clustering-based-recommendation-system-by-tuning-its-hyper-parameters" class="level4" data-number="3.7.1">
<h4 data-number="3.7.1" class="anchored" data-anchor-id="improving-clustering-based-recommendation-system-by-tuning-its-hyper-parameters"><span class="header-section-number">3.7.1</span> Improving clustering-based recommendation system by tuning its hyper-parameters</h4>
<div id="0492a7a7" class="cell">
<div class="sourceCode cell-code" id="cb75"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the parameter space to tune</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>param_grid <span class="op">=</span> {<span class="st">'n_cltr_u'</span>: [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">10</span>], <span class="st">'n_cltr_i'</span>: [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">10</span> ],</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>              <span class="st">'n_epochs'</span>: [<span class="dv">10</span>, <span class="dv">30</span>, <span class="dv">40</span>]}</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Performing 3-fold grid search cross-validation</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>gs <span class="op">=</span> GridSearchCV(CoClustering, param_grid, measures <span class="op">=</span> [<span class="st">'rmse'</span>], cv <span class="op">=</span> <span class="dv">3</span>, n_jobs <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Fitting data</span></span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>gs.fit(data)</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Best RMSE score</span></span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(gs.best_score[<span class="st">'rmse'</span>])</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Combination of parameters that gave the best RMSE score</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(gs.best_params[<span class="st">'rmse'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Think About It</strong>: How do the parameters affect the performance of the model? Can we improve the performance of the model further? Check the available hyperparameters <a href="https://surprise.readthedocs.io/en/stable/co_clustering.html">here</a>. - The coclustering algorithm has some tunnable parameters. - Tweeking theses parameters might improve the predictions.</p>
<div id="0a327e65" class="cell">
<div class="sourceCode cell-code" id="cb76"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the tuned Coclustering algorithm</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>best_params_clust <span class="op">=</span> gs.best_params[<span class="st">'rmse'</span>]</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>best_n_cltr_u <span class="op">=</span> best_params_clust[<span class="st">'n_cltr_u'</span>]</span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>best_n_cltr_i <span class="op">=</span> best_params_clust[<span class="st">'n_cltr_i'</span>]</span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>best_n_epochs <span class="op">=</span> best_params_clust[<span class="st">'n_epochs'</span>]</span>
<span id="cb76-6"><a href="#cb76-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-7"><a href="#cb76-7" aria-hidden="true" tabindex="-1"></a>clustering_model_tuned <span class="op">=</span> CoClustering(n_cltr_u<span class="op">=</span>best_n_cltr_u,</span>
<span id="cb76-8"><a href="#cb76-8" aria-hidden="true" tabindex="-1"></a>                                      n_cltr_i<span class="op">=</span>best_n_cltr_i,</span>
<span id="cb76-9"><a href="#cb76-9" aria-hidden="true" tabindex="-1"></a>                                      n_epochs<span class="op">=</span>best_n_epochs,</span>
<span id="cb76-10"><a href="#cb76-10" aria-hidden="true" tabindex="-1"></a>                                      random_state<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb76-11"><a href="#cb76-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-12"><a href="#cb76-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the algorithm on the trainset</span></span>
<span id="cb76-13"><a href="#cb76-13" aria-hidden="true" tabindex="-1"></a>clustering_model_tuned.fit(trainset)</span>
<span id="cb76-14"><a href="#cb76-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-15"><a href="#cb76-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the function precision_recall_at_k to compute precision@k, recall@k, F1-Score, and RMSE</span></span>
<span id="cb76-16"><a href="#cb76-16" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(clustering_model_tuned, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The performance of this tuned model has not increased compared to the baseline coclustering model.</p>
<div id="1263b579" class="cell">
<div class="sourceCode cell-code" id="cb77"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Using co_clustering_optimized model to recommend for userId 6958 and song_id 1671</span></span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>user_id_interaction, song_id_interaction, play_count_interaction <span class="op">=</span> <span class="dv">6958</span>, <span class="dv">1671</span>, <span class="dv">2</span></span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>clustering_model_tuned.predict(user_id_interaction, song_id_interaction,</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>                                  r_ui <span class="op">=</span> play_count_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="eb979a70" class="cell">
<div class="sourceCode cell-code" id="cb78"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use Co_clustering based optimized model to recommend for userId 6958 and song_id 3232 with unknown baseline play_count</span></span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a>user_id_no_interaction, song_id_no_interaction <span class="op">=</span> (<span class="dv">6958</span>, <span class="dv">3232</span>)</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>clustering_model_tuned.predict(user_id_no_interaction, song_id_no_interaction)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The predicted play count</strong> for the <strong>interacted user-song pair is 1.12</strong>. The <strong>actual play count is 2</strong>, so the prediction is far from the actual.</p>
<p><strong>The predicted play count</strong> the for the <strong>user-song pair with no interaction is 1.31.</strong></p>
</section>
<section id="implementing-the-recommendation-algorithm-based-on-optimized-coclustering-model" class="level4" data-number="3.7.2">
<h4 data-number="3.7.2" class="anchored" data-anchor-id="implementing-the-recommendation-algorithm-based-on-optimized-coclustering-model"><span class="header-section-number">3.7.2</span> Implementing the recommendation algorithm based on optimized CoClustering model</h4>
<div id="f8b83f5c" class="cell">
<div class="sourceCode cell-code" id="cb79"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Getting top 5 recommendations for user_id 6958 using "Co-clustering based optimized" algorithm</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>recommendations <span class="op">=</span> get_recommendations(df_final, user_id_interaction, <span class="dv">5</span>,</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>                                      clustering_model_tuned)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="correcting-the-play_count-and-ranking-the-above-songs" class="level3" data-number="3.8">
<h3 data-number="3.8" class="anchored" data-anchor-id="correcting-the-play_count-and-ranking-the-above-songs"><span class="header-section-number">3.8</span> Correcting the play_count and Ranking the above songs</h3>
<div id="2e6ea476" class="cell" data-scrolled="true">
<div class="sourceCode cell-code" id="cb80"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Ranking songs based on the above recommendations</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>ranking_songs(recommendations, df_songs_count_freq)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Above we can see the list of the songs recommended by the svd model</strong>. - the top recommendation is the song 7224 with 2.93 play_counts. - the fifth recommendation is the song 4831 with 2.34 playcounts. - all the recommended songs have a predicted playcounts greater than 2. - the songs are the same recommended by the user-user colaborative filtering model.</p>
</section>
<section id="content-based-recommendation-systems" class="level3" data-number="3.9">
<h3 data-number="3.9" class="anchored" data-anchor-id="content-based-recommendation-systems"><span class="header-section-number">3.9</span> Content Based Recommendation Systems</h3>
<p><strong>Think About It:</strong> So far we have only used the play_count of songs to find recommendations but we have other information/features on songs as well. Can we take those song features into account? - Yes we can recommend songs which features are similar to a target song</p>
<div id="d6358ad3" class="cell">
<div class="sourceCode cell-code" id="cb81"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Concatenate the "title", "release", "artist_name" columns to create a different column named "text"</span></span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>df_final[<span class="st">'text'</span>] <span class="op">=</span> df_final[<span class="st">'title'</span>] <span class="op">+</span> <span class="st">' '</span> <span class="op">+</span> df_final[<span class="st">'release'</span>] <span class="op">+</span> <span class="st">' '</span> <span class="op">+</span>  df_final[<span class="st">'artist_name'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="1ea794dc" class="cell">
<div class="sourceCode cell-code" id="cb82"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Selecting a random subset of the original data</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>df_small <span class="op">=</span> df_final.sample(n <span class="op">=</span> <span class="dv">100000</span>, random_state <span class="op">=</span> <span class="dv">42</span>)</span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Select the columns 'user_id', 'song_id', 'play_count', 'title', 'text' from df_small data</span></span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>df_small <span class="op">=</span> df_small[[<span class="st">'user_id'</span>, <span class="st">'song_id'</span>, <span class="st">'play_count'</span>, <span class="st">'title'</span>, <span class="st">'text'</span>]]</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Drop the duplicates from the title column</span></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>df_small <span class="op">=</span> df_small.drop_duplicates(<span class="st">'title'</span>)</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the title column as the index</span></span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>df_small.set_index(<span class="st">'title'</span>, inplace<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a><span class="co"># See the first 5 records of the df_small dataset</span></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>df_small.head(<span class="dv">5</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="00dcce40" class="cell">
<div class="sourceCode cell-code" id="cb83"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the series of indices from the data</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>indices <span class="op">=</span> pd.Series(df_small.index)</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us see the first 5 indices</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>indices[:<span class="dv">5</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ff85d8e0" class="cell">
<div class="sourceCode cell-code" id="cb84"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Importing necessary packages to work with text data</span></span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> nltk</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Download punkt library</span></span>
<span id="cb84-5"><a href="#cb84-5" aria-hidden="true" tabindex="-1"></a>nltk.download(<span class="st">"punkt"</span>)</span>
<span id="cb84-6"><a href="#cb84-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-7"><a href="#cb84-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Download stopwords library</span></span>
<span id="cb84-8"><a href="#cb84-8" aria-hidden="true" tabindex="-1"></a>nltk.download(<span class="st">'stopwords'</span>)</span>
<span id="cb84-9"><a href="#cb84-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-10"><a href="#cb84-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Download wordnet</span></span>
<span id="cb84-11"><a href="#cb84-11" aria-hidden="true" tabindex="-1"></a>nltk.download(<span class="st">'wordnet'</span>)</span>
<span id="cb84-12"><a href="#cb84-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-13"><a href="#cb84-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Import regular expression</span></span>
<span id="cb84-14"><a href="#cb84-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> re</span>
<span id="cb84-15"><a href="#cb84-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-16"><a href="#cb84-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Import word_tokenizer</span></span>
<span id="cb84-17"><a href="#cb84-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nltk <span class="im">import</span> word_tokenize</span>
<span id="cb84-18"><a href="#cb84-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-19"><a href="#cb84-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Import WordNetLemmatizer</span></span>
<span id="cb84-20"><a href="#cb84-20" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nltk.stem <span class="im">import</span> WordNetLemmatizer</span>
<span id="cb84-21"><a href="#cb84-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-22"><a href="#cb84-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Import stopwords</span></span>
<span id="cb84-23"><a href="#cb84-23" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> nltk.corpus <span class="im">import</span> stopwords</span>
<span id="cb84-24"><a href="#cb84-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb84-25"><a href="#cb84-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Import CountVectorizer and TfidfVectorizer</span></span>
<span id="cb84-26"><a href="#cb84-26" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.feature_extraction.text <span class="im">import</span> CountVectorizer, TfidfVectorizer</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We will create a <strong>function to pre-process the text data:</strong></p>
<div id="5a72fa16" class="cell">
<div class="sourceCode cell-code" id="cb85"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a function to tokenize the text</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tokenize(text):</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Making each letter as lowercase and removing non-alphabetical text</span></span>
<span id="cb85-5"><a href="#cb85-5" aria-hidden="true" tabindex="-1"></a>    text <span class="op">=</span> re.sub(<span class="vs">r"[^a-zA-Z]"</span>, <span class="st">" "</span>, text.lower())</span>
<span id="cb85-6"><a href="#cb85-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-7"><a href="#cb85-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extracting each word in the text</span></span>
<span id="cb85-8"><a href="#cb85-8" aria-hidden="true" tabindex="-1"></a>    tokens <span class="op">=</span> word_tokenize(text)</span>
<span id="cb85-9"><a href="#cb85-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-10"><a href="#cb85-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Removing stopwords</span></span>
<span id="cb85-11"><a href="#cb85-11" aria-hidden="true" tabindex="-1"></a>    words <span class="op">=</span> [word <span class="cf">for</span> word <span class="kw">in</span> tokens <span class="cf">if</span> word <span class="kw">not</span> <span class="kw">in</span> stopwords.words(<span class="st">"english"</span>)]</span>
<span id="cb85-12"><a href="#cb85-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-13"><a href="#cb85-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Lemmatize the words</span></span>
<span id="cb85-14"><a href="#cb85-14" aria-hidden="true" tabindex="-1"></a>    text_lems <span class="op">=</span> [WordNetLemmatizer().lemmatize(lem).strip() <span class="cf">for</span> lem <span class="kw">in</span> words]</span>
<span id="cb85-15"><a href="#cb85-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb85-16"><a href="#cb85-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> text_lems</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8620b57a" class="cell">
<div class="sourceCode cell-code" id="cb86"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create tfidf vectorizer</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>tfidf <span class="op">=</span> TfidfVectorizer(tokenizer <span class="op">=</span> tokenize)</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Fit_transfrom the above vectorizer on the text column and then convert the output into an array</span></span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>songs_tfidf <span class="op">=</span> tfidf.fit_transform(df_small[<span class="st">'text'</span>].values).toarray()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6ebad1d8" class="cell">
<div class="sourceCode cell-code" id="cb87"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute the cosine similarity for the tfidf above output</span></span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>similar_songs <span class="op">=</span> cosine_similarity(songs_tfidf, songs_tfidf)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally, let’s create a function to find most similar songs to recommend for a given song.</p>
<div id="d6454a89" class="cell">
<div class="sourceCode cell-code" id="cb88"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Function that takes in song title as input and returns the top 10 recommended songs</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> recommendations(title, similar_songs, indices <span class="op">=</span> indices, data <span class="op">=</span> df_small):</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>    recommended_songs <span class="op">=</span> []</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Getting the index of the song that matches the title</span></span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>    idx <span class="op">=</span> indices[indices <span class="op">==</span> title].index[<span class="dv">0</span>]</span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Creating a Series with the similarity scores in descending order</span></span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a>    score_series <span class="op">=</span> pd.Series(similar_songs[idx]).sort_values(ascending <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Getting the indexes of the 10 most similar songs</span></span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a>    top_10_indexes <span class="op">=</span> <span class="bu">list</span>(score_series.iloc[<span class="dv">1</span>:<span class="dv">11</span>].index)</span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Populating the list with the titles of the best 10 matching songs</span></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> top_10_indexes:</span>
<span id="cb88-17"><a href="#cb88-17" aria-hidden="true" tabindex="-1"></a>        recommended_songs.append(<span class="bu">list</span>(data.index)[i])</span>
<span id="cb88-18"><a href="#cb88-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-19"><a href="#cb88-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> recommended_songs</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Recommending 10 songs similar to Learn to Fly</p>
<div id="93d7a62b" class="cell">
<div class="sourceCode cell-code" id="cb89"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Make the recommendation for the song with title 'Learn To Fly'</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>recommendations(<span class="st">"Learn To Fly"</span>, similar_songs, indices, df_small)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>The list above contains the songs predicted similar to the song Learn To Fly</strong> - To verify that the recommendation is working, we can check if the “title”, “release” and “artist_name” of the predicted songs are similar to the ones of the target song. They seems to be different. - We need more compelling features for this task, the genre of the songs or some tags describing each songs …</p>
</section>
</section>
<section id="conclusion-and-recommendations" class="level2" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="conclusion-and-recommendations"><span class="header-section-number">4</span> <strong>Conclusion and Recommendations</strong></h2>
<p><strong>1. Comparison of various techniques and their relative performance based on chosen Metric (Measure of success)</strong>: - How do different techniques perform? Which one is performing relatively better? Is there scope to improve the performance further?</p>
<ul>
<li>The F1 scores of the models built so far are:
<ul>
<li>user-user colaborative filtering baseline model: 0.504</li>
<li>user-user colaborative filtering tuned model: <strong>0.513</strong></li>
<li>item-item colaborative filtering baseline model: 0.397</li>
<li>item-item colaborative filtering tuned model: 0.483</li>
<li>matrix factorization baseline model: 0.498</li>
<li>matrix factorization tuned model: 0.504</li>
<li>coclustering baseline model: 0.472</li>
<li>coclustering tuned model: 0.472</li>
<li>content based model: no score computed</li>
<li>popularity based model : no score computed</li>
</ul></li>
<li>The model with the best F1 score is the <strong>user-user colaborative filtering tuned model</strong>.</li>
<li>The F1 scores are very low. We can definitely improve these scores. This can be done by testing different technics, such as:</li>
<li>data balancing</li>
<li>changing the cutoffs thresholds.</li>
<li>customizing the implementation of the algorithms for this specific problem</li>
<li>collecting more data if possible</li>
<li>building hybrid recommendations systems. This can be done by analyzing the observations for which the model is not performing well and use another model which performs better on those observations. Thus combining the predictions of both models at the same time.</li>
<li>For the content based model, we need more features describing the songs, for example the genres of the songs.</li>
</ul>
<p><strong>2. Refined insights</strong>: - What are the most meaningful insights from the data relevant to the problem? - The data is imbalanced, most of the play counts are 1 and 2, very few are 3, 4 or 5. - Adding more boservations with <strong>high interactions</strong> will increase the performance of the models. - Some observations date from 1969, we need further analysis to see how the rejection of these observations impacts the quality of the predictions. This could increase performance as it would likely reduce the sparsity of matrices and improve similarity measures. some old songs are no longer listened to and users tastes may have changed.</p>
<p><strong>3. Proposal for the final solution design:</strong> - What model do you propose to be adopted? Why is this the best solution to adopt? - Based on this analysis, the proposed model is the <strong>user-user colaborative filtering tuned model</strong>. This model has the best F1 score and the metric suited for this business is the F1 score. - We can increase the performance of this model by investigating further technics as mentionned above.</p>
</section>
<section id="further-analysis" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="further-analysis"><span class="header-section-number">5</span> <strong>Further analysis</strong></h2>
<p>Testing the cutoffs thresholds and discarding old songs</p>
<div id="ce0ca4dc" class="cell">
<div class="sourceCode cell-code" id="cb90"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.merge(count_df, song_df.drop_duplicates(<span class="st">'song_id'</span>), how<span class="op">=</span><span class="st">'left'</span>)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply label encoding for "user_id" and "song_id"</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.preprocessing <span class="im">import</span> LabelEncoder</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="co">#storing transformers in a dictionnary for decoding if needed</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>label_object <span class="op">=</span> {}</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>categorical_columns <span class="op">=</span> [<span class="st">'user_id'</span>,<span class="st">'song_id'</span>]</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> col <span class="kw">in</span> categorical_columns:</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>  labelencoder <span class="op">=</span> LabelEncoder()</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>  labelencoder.fit(df[col])</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>  df[col] <span class="op">=</span> labelencoder.fit_transform(df[col])</span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>  label_object[col] <span class="op">=</span> labelencoder</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a><span class="co">#saving the original df in df_copy</span></span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a>df_copy <span class="op">=</span> df.copy()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="31dbd726" class="cell">
<div class="sourceCode cell-code" id="cb91"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the column containing the users</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>users <span class="op">=</span> df.user_id</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dictionary that maps users(listeners) to the number of songs that they have listened to</span></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>playing_count <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb91-6"><a href="#cb91-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-7"><a href="#cb91-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> user <span class="kw">in</span> users:</span>
<span id="cb91-8"><a href="#cb91-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we already have the user, just add 1 to their playing count</span></span>
<span id="cb91-9"><a href="#cb91-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> user <span class="kw">in</span> playing_count:</span>
<span id="cb91-10"><a href="#cb91-10" aria-hidden="true" tabindex="-1"></a>        playing_count[user] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb91-11"><a href="#cb91-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-12"><a href="#cb91-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Otherwise, set their playing count to 1</span></span>
<span id="cb91-13"><a href="#cb91-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb91-14"><a href="#cb91-14" aria-hidden="true" tabindex="-1"></a>        playing_count[user] <span class="op">=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="db130573" class="cell">
<div class="sourceCode cell-code" id="cb92"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We want our users to have listened at least 90 songs</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>SONG_COUNT_CUTOFF <span class="op">=</span> <span class="dv">160</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a list of users who need to be removed</span></span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a>remove_users <span class="op">=</span> []</span>
<span id="cb92-6"><a href="#cb92-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-7"><a href="#cb92-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> user, num_songs <span class="kw">in</span> playing_count.items():</span>
<span id="cb92-8"><a href="#cb92-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-9"><a href="#cb92-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_songs <span class="op">&lt;</span> SONG_COUNT_CUTOFF:</span>
<span id="cb92-10"><a href="#cb92-10" aria-hidden="true" tabindex="-1"></a>        remove_users.append(user)</span>
<span id="cb92-11"><a href="#cb92-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb92-12"><a href="#cb92-12" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.loc[ <span class="op">~</span> df.user_id.isin(remove_users)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b4cfcad8" class="cell">
<div class="sourceCode cell-code" id="cb93"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the column containing the songs</span></span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>songs <span class="op">=</span> df.song_id</span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dictionary that maps songs to its number of users(listeners)</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a>playing_count <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> song <span class="kw">in</span> songs:</span>
<span id="cb93-8"><a href="#cb93-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we already have the song, just add 1 to their playing count</span></span>
<span id="cb93-9"><a href="#cb93-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> song <span class="kw">in</span> playing_count:</span>
<span id="cb93-10"><a href="#cb93-10" aria-hidden="true" tabindex="-1"></a>        playing_count[song] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb93-11"><a href="#cb93-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-12"><a href="#cb93-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Otherwise, set their playing count to 1</span></span>
<span id="cb93-13"><a href="#cb93-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb93-14"><a href="#cb93-14" aria-hidden="true" tabindex="-1"></a>        playing_count[song] <span class="op">=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="b68e773b" class="cell">
<div class="sourceCode cell-code" id="cb94"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="co"># We want our song to be listened by at least 120 users to be considred</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>LISTENER_COUNT_CUTOFF <span class="op">=</span> <span class="dv">160</span></span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-4"><a href="#cb94-4" aria-hidden="true" tabindex="-1"></a>remove_songs <span class="op">=</span> []</span>
<span id="cb94-5"><a href="#cb94-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-6"><a href="#cb94-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> song, num_users <span class="kw">in</span> playing_count.items():</span>
<span id="cb94-7"><a href="#cb94-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_users <span class="op">&lt;</span> LISTENER_COUNT_CUTOFF:</span>
<span id="cb94-8"><a href="#cb94-8" aria-hidden="true" tabindex="-1"></a>        remove_songs.append(song)</span>
<span id="cb94-9"><a href="#cb94-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb94-10"><a href="#cb94-10" aria-hidden="true" tabindex="-1"></a>df_final <span class="op">=</span> df.loc[ <span class="op">~</span> df.song_id.isin(remove_songs)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e49cefa2" class="cell">
<div class="sourceCode cell-code" id="cb95"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>df_final.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6d6a8023" class="cell">
<div class="sourceCode cell-code" id="cb96"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Keeping the records with play counts greater than 5 by decreasing their play_count to 5</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>df_final.loc[df_final.play_count<span class="op">&gt;</span><span class="dv">5</span>, <span class="st">'play_count'</span>] <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a><span class="co"># discarding old observations</span></span>
<span id="cb96-5"><a href="#cb96-5" aria-hidden="true" tabindex="-1"></a>df_final <span class="op">=</span> df_final[(df_final.year <span class="op">&gt;</span> <span class="dv">1999</span>) <span class="op">|</span> (df_final.year <span class="op">==</span> <span class="dv">0</span>)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="25a2baa7" class="cell">
<div class="sourceCode cell-code" id="cb97"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>df_final.shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f6a31304" class="cell">
<div class="sourceCode cell-code" id="cb98"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a barplot plot with y label as "number of titles played" and x -axis year</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>nbr_titles_played_by_year <span class="op">=</span> df_final.groupby(<span class="st">'year'</span>).title.nunique()</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the figure size</span></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">7</span>, <span class="dv">5</span>))</span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a><span class="co">#from the previous cell, we could see there is an abnormal year 0, which seems to be</span></span>
<span id="cb98-7"><a href="#cb98-7" aria-hidden="true" tabindex="-1"></a><span class="co">#a default, so we're dropping that year</span></span>
<span id="cb98-8"><a href="#cb98-8" aria-hidden="true" tabindex="-1"></a>plt.bar(x<span class="op">=</span>nbr_titles_played_by_year.index[<span class="dv">1</span>:], height<span class="op">=</span>nbr_titles_played_by_year[<span class="dv">1</span>:])</span>
<span id="cb98-9"><a href="#cb98-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-10"><a href="#cb98-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the x label of the plot</span></span>
<span id="cb98-11"><a href="#cb98-11" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'year'</span>)</span>
<span id="cb98-12"><a href="#cb98-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-13"><a href="#cb98-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the y label of the plot</span></span>
<span id="cb98-14"><a href="#cb98-14" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'number of titles played'</span>)</span>
<span id="cb98-15"><a href="#cb98-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-16"><a href="#cb98-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting all the ticks</span></span>
<span id="cb98-17"><a href="#cb98-17" aria-hidden="true" tabindex="-1"></a>plt.xticks(ticks<span class="op">=</span>nbr_titles_played_by_year.index[<span class="dv">1</span>:], rotation<span class="op">=</span><span class="dv">90</span>, size<span class="op">=</span><span class="dv">7</span>)</span>
<span id="cb98-18"><a href="#cb98-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-19"><a href="#cb98-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Show the plot</span></span>
<span id="cb98-20"><a href="#cb98-20" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fa6067ef" class="cell">
<div class="sourceCode cell-code" id="cb99"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Instantiating Reader scale with expected rating scale</span></span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a> <span class="co">#use rating scale (0, 5)</span></span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a>reader <span class="op">=</span> Reader(rating_scale<span class="op">=</span>(<span class="dv">0</span>, <span class="dv">5</span>))</span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Loading the dataset</span></span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a> <span class="co"># Take only "user_id","song_id", and "play_count"</span></span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> Dataset.load_from_df(df_final[[<span class="st">'user_id'</span>,    <span class="st">'song_id'</span>, <span class="st">'play_count'</span>]],</span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>                            reader<span class="op">=</span>reader)</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Splitting the data into train and test dataset</span></span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a> <span class="co"># Take test_size = 0.4, random_state = 42</span></span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>trainset, testset <span class="op">=</span> train_test_split(data, test_size<span class="op">=</span><span class="fl">0.4</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="fffbcb93" class="cell">
<div class="sourceCode cell-code" id="cb100"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build the default user-user-similarity model</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>sim_options<span class="op">=</span><span class="bu">dict</span>(name<span class="op">=</span><span class="st">'cosine'</span>, user_based<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-4"><a href="#cb100-4" aria-hidden="true" tabindex="-1"></a><span class="co"># KNN algorithm is used to find desired similar items</span></span>
<span id="cb100-5"><a href="#cb100-5" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use random_state = 1</span></span>
<span id="cb100-6"><a href="#cb100-6" aria-hidden="true" tabindex="-1"></a>sim_user_user_model <span class="op">=</span> KNNBasic(sim_options<span class="op">=</span>sim_options, random_state<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb100-7"><a href="#cb100-7" aria-hidden="true" tabindex="-1"></a>                               verbose<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb100-8"><a href="#cb100-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-9"><a href="#cb100-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the algorithm on the trainset, and predict play_count for the testset</span></span>
<span id="cb100-10"><a href="#cb100-10" aria-hidden="true" tabindex="-1"></a>sim_user_user_model.fit(trainset)</span>
<span id="cb100-11"><a href="#cb100-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb100-12"><a href="#cb100-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us compute precision@k, recall@k, and f_1 score with k = 30</span></span>
<span id="cb100-13"><a href="#cb100-13" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use sim_user_user model</span></span>
<span id="cb100-14"><a href="#cb100-14" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(sim_user_user_model, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The new F1 score is 0.66. This is better than 0.51 obtained in the conclusion. The precision is still bad.</p>
</section>
<section id="tuning-the-model" class="level2" data-number="6">
<h2 data-number="6" class="anchored" data-anchor-id="tuning-the-model"><span class="header-section-number">6</span> Tuning the model</h2>
<div id="859f4902" class="cell">
<div class="sourceCode cell-code" id="cb101"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting up parameter grid to tune the hyperparameters</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>params_grid <span class="op">=</span> <span class="bu">dict</span>(k<span class="op">=</span>[<span class="dv">60</span>, <span class="dv">80</span>, <span class="dv">100</span>], min_k<span class="op">=</span>[<span class="dv">10</span>, <span class="dv">40</span>, <span class="dv">50</span>],</span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>                   sim_options<span class="op">=</span><span class="bu">dict</span>(name<span class="op">=</span>[<span class="st">'msd'</span>, <span class="st">'cosine'</span>],</span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>                                    <span class="co">#min_support = [5, 10, 20],</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>                                    user_based<span class="op">=</span>[<span class="va">True</span>]))</span>
<span id="cb101-6"><a href="#cb101-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Performing 3-fold cross-validation to tune the hyperparameters</span></span>
<span id="cb101-7"><a href="#cb101-7" aria-hidden="true" tabindex="-1"></a>gs <span class="op">=</span> GridSearchCV(KNNBasic, param_grid<span class="op">=</span>params_grid, cv<span class="op">=</span><span class="dv">3</span>, measures<span class="op">=</span>[<span class="st">'rmse'</span>],</span>
<span id="cb101-8"><a href="#cb101-8" aria-hidden="true" tabindex="-1"></a>                  n_jobs<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb101-9"><a href="#cb101-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-10"><a href="#cb101-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Fitting the data</span></span>
<span id="cb101-11"><a href="#cb101-11" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use entire data for GridSearch</span></span>
<span id="cb101-12"><a href="#cb101-12" aria-hidden="true" tabindex="-1"></a>gs.fit(data)</span>
<span id="cb101-13"><a href="#cb101-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-14"><a href="#cb101-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Best RMSE score</span></span>
<span id="cb101-15"><a href="#cb101-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best RMSE score:"</span>, gs.best_score[<span class="st">'rmse'</span>])</span>
<span id="cb101-16"><a href="#cb101-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-17"><a href="#cb101-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Combination of parameters that gave the best RMSE score</span></span>
<span id="cb101-18"><a href="#cb101-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Best_params:"</span>, gs.best_params[<span class="st">'rmse'</span>])</span>
<span id="cb101-19"><a href="#cb101-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-20"><a href="#cb101-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the best model found in above gridsearch</span></span>
<span id="cb101-21"><a href="#cb101-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Using the optimal similarity measure for user-user based collaborative filtering</span></span>
<span id="cb101-22"><a href="#cb101-22" aria-hidden="true" tabindex="-1"></a>best_params <span class="op">=</span> gs.best_params[<span class="st">'rmse'</span>]</span>
<span id="cb101-23"><a href="#cb101-23" aria-hidden="true" tabindex="-1"></a>best_k <span class="op">=</span> best_params[<span class="st">'k'</span>]</span>
<span id="cb101-24"><a href="#cb101-24" aria-hidden="true" tabindex="-1"></a>best_min_k <span class="op">=</span> best_params[<span class="st">'min_k'</span>]</span>
<span id="cb101-25"><a href="#cb101-25" aria-hidden="true" tabindex="-1"></a>best_sim_options <span class="op">=</span> best_params[<span class="st">'sim_options'</span>]</span>
<span id="cb101-26"><a href="#cb101-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-27"><a href="#cb101-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Creating an instance of KNNBasic with optimal hyperparameter values</span></span>
<span id="cb101-28"><a href="#cb101-28" aria-hidden="true" tabindex="-1"></a>sim_user_user_tuned_model <span class="op">=</span> KNNBasic(k <span class="op">=</span> best_k, min_k<span class="op">=</span>best_min_k,</span>
<span id="cb101-29"><a href="#cb101-29" aria-hidden="true" tabindex="-1"></a>                                     sim_options<span class="op">=</span>best_sim_options,</span>
<span id="cb101-30"><a href="#cb101-30" aria-hidden="true" tabindex="-1"></a>                                     random_state<span class="op">=</span><span class="dv">1</span>, verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb101-31"><a href="#cb101-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-32"><a href="#cb101-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Training the algorithm on the trainset</span></span>
<span id="cb101-33"><a href="#cb101-33" aria-hidden="true" tabindex="-1"></a>sim_user_user_tuned_model.fit(trainset)</span>
<span id="cb101-34"><a href="#cb101-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb101-35"><a href="#cb101-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us compute precision@k and recall@k also</span></span>
<span id="cb101-36"><a href="#cb101-36" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(sim_user_user_tuned_model, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Tuning has not increased the performance.</p>
</section>
<section id="balancing-the-data" class="level2" data-number="7">
<h2 data-number="7" class="anchored" data-anchor-id="balancing-the-data"><span class="header-section-number">7</span> Balancing the data</h2>
<p>We only balance the trainset. As balancing the whole dataset would leak information of the testset in the training.</p>
<div id="92fcda78" class="cell">
<div class="sourceCode cell-code" id="cb102"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>trainset_df <span class="op">=</span> pd.DataFrame(trainset.build_testset(), columns <span class="op">=</span> [<span class="st">'user_id'</span>, <span class="st">'song_id'</span>, <span class="st">'play_count'</span>])</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="co"># We will oversample the under representated classes using smote</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> imblearn.over_sampling <span class="im">import</span> SMOTE</span>
<span id="cb102-5"><a href="#cb102-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-6"><a href="#cb102-6" aria-hidden="true" tabindex="-1"></a>smote <span class="op">=</span> SMOTE(random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb102-7"><a href="#cb102-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-8"><a href="#cb102-8" aria-hidden="true" tabindex="-1"></a><span class="co">#balancing with smote</span></span>
<span id="cb102-9"><a href="#cb102-9" aria-hidden="true" tabindex="-1"></a>x, y <span class="op">=</span> smote.fit_resample(trainset_df[[<span class="st">'user_id'</span>, <span class="st">'song_id'</span>]], trainset_df.play_count)</span>
<span id="cb102-10"><a href="#cb102-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-11"><a href="#cb102-11" aria-hidden="true" tabindex="-1"></a>trainset_df_balanced <span class="op">=</span> pd.concat([x,y], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb102-12"><a href="#cb102-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-13"><a href="#cb102-13" aria-hidden="true" tabindex="-1"></a><span class="co"># converting the trainset balanced into suprise dataset</span></span>
<span id="cb102-14"><a href="#cb102-14" aria-hidden="true" tabindex="-1"></a>trainset_data_balanced <span class="op">=</span> Dataset.load_from_df(trainset_df_balanced[[<span class="st">'user_id'</span>,  <span class="st">'song_id'</span>, <span class="st">'play_count'</span>]],</span>
<span id="cb102-15"><a href="#cb102-15" aria-hidden="true" tabindex="-1"></a>                            reader<span class="op">=</span>reader)</span>
<span id="cb102-16"><a href="#cb102-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-17"><a href="#cb102-17" aria-hidden="true" tabindex="-1"></a><span class="co"># rebuild the trainset for surprise algorithms training</span></span>
<span id="cb102-18"><a href="#cb102-18" aria-hidden="true" tabindex="-1"></a>trainset_balanced <span class="op">=</span> trainset_data_balanced.build_full_trainset()</span>
<span id="cb102-19"><a href="#cb102-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb102-20"><a href="#cb102-20" aria-hidden="true" tabindex="-1"></a><span class="co"># balanced the whole dataset for comparison purposes</span></span>
<span id="cb102-21"><a href="#cb102-21" aria-hidden="true" tabindex="-1"></a>x2, y2 <span class="op">=</span> smote.fit_resample(df_final[[<span class="st">'user_id'</span>, <span class="st">'song_id'</span>]], df_final.play_count)</span>
<span id="cb102-22"><a href="#cb102-22" aria-hidden="true" tabindex="-1"></a>df_final_balanced <span class="op">=</span> pd.concat([x2,y2], axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb102-23"><a href="#cb102-23" aria-hidden="true" tabindex="-1"></a>data_balanced <span class="op">=</span> Dataset.load_from_df(df_final_balanced[[<span class="st">'user_id'</span>,  <span class="st">'song_id'</span>, <span class="st">'play_count'</span>]],</span>
<span id="cb102-24"><a href="#cb102-24" aria-hidden="true" tabindex="-1"></a>                            reader<span class="op">=</span>reader)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="6f149146" class="cell">
<div class="sourceCode cell-code" id="cb103"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>trainset_df_balanced.play_count.value_counts()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="58dd7938" class="cell">
<div class="sourceCode cell-code" id="cb104"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build the default user-user-similarity model</span></span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>sim_options<span class="op">=</span><span class="bu">dict</span>(name<span class="op">=</span><span class="st">'cosine'</span>, user_based<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="co"># KNN algorithm is used to find desired similar items</span></span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use random_state = 1</span></span>
<span id="cb104-6"><a href="#cb104-6" aria-hidden="true" tabindex="-1"></a>sim_user_user_model <span class="op">=</span> KNNBasic(k <span class="op">=</span> <span class="dv">40</span>, min_k<span class="op">=</span><span class="dv">1</span>, sim_options<span class="op">=</span>sim_options, random_state<span class="op">=</span><span class="dv">1</span>,</span>
<span id="cb104-7"><a href="#cb104-7" aria-hidden="true" tabindex="-1"></a>                               verbose<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb104-8"><a href="#cb104-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-9"><a href="#cb104-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the algorithm on the trainset, and predict play_count for the testset</span></span>
<span id="cb104-10"><a href="#cb104-10" aria-hidden="true" tabindex="-1"></a>sim_user_user_model.fit(trainset_balanced)</span>
<span id="cb104-11"><a href="#cb104-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-12"><a href="#cb104-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us compute precision@k, recall@k, and f_1 score with k = 30</span></span>
<span id="cb104-13"><a href="#cb104-13" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use sim_user_user model</span></span>
<span id="cb104-14"><a href="#cb104-14" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(sim_user_user_model, k<span class="op">=</span><span class="dv">30</span>, threshold<span class="op">=</span><span class="fl">1.5</span>,testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Balancing the data has not increased the F1 score</p>
</section>
<section id="examining-where-the-model-is-not-performing-well" class="level2" data-number="8">
<h2 data-number="8" class="anchored" data-anchor-id="examining-where-the-model-is-not-performing-well"><span class="header-section-number">8</span> Examining where the model is not performing well</h2>
<div id="6512229a" class="cell">
<div class="sourceCode cell-code" id="cb105"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's build a pandas dataframe with all the predictions</span></span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_Iu(uid):</span>
<span id="cb105-3"><a href="#cb105-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Return the number of items rated by given user</span></span>
<span id="cb105-4"><a href="#cb105-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-5"><a href="#cb105-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb105-6"><a href="#cb105-6" aria-hidden="true" tabindex="-1"></a><span class="co">        uid: The raw id of the user.</span></span>
<span id="cb105-7"><a href="#cb105-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb105-8"><a href="#cb105-8" aria-hidden="true" tabindex="-1"></a><span class="co">        The number of items rated by the user.</span></span>
<span id="cb105-9"><a href="#cb105-9" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb105-10"><a href="#cb105-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb105-11"><a href="#cb105-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(trainset.ur[trainset.to_inner_uid(uid)])</span>
<span id="cb105-12"><a href="#cb105-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:  <span class="co"># user was not part of the trainset</span></span>
<span id="cb105-13"><a href="#cb105-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb105-14"><a href="#cb105-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-15"><a href="#cb105-15" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_Ui(iid):</span>
<span id="cb105-16"><a href="#cb105-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Return the number of users that have rated given item</span></span>
<span id="cb105-17"><a href="#cb105-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb105-18"><a href="#cb105-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb105-19"><a href="#cb105-19" aria-hidden="true" tabindex="-1"></a><span class="co">        iid: The raw id of the item.</span></span>
<span id="cb105-20"><a href="#cb105-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb105-21"><a href="#cb105-21" aria-hidden="true" tabindex="-1"></a><span class="co">        The number of users that have rated the item.</span></span>
<span id="cb105-22"><a href="#cb105-22" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb105-23"><a href="#cb105-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb105-24"><a href="#cb105-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(trainset.ir[trainset.to_inner_iid(iid)])</span>
<span id="cb105-25"><a href="#cb105-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">ValueError</span>:  <span class="co"># item was not part of the trainset</span></span>
<span id="cb105-26"><a href="#cb105-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="506c0f4f" class="cell">
<div class="sourceCode cell-code" id="cb106"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>predictions <span class="op">=</span> sim_user_user_model.test(testset)</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> pd.DataFrame(predictions, columns<span class="op">=</span>[<span class="st">'uid'</span>, <span class="st">'iid'</span>, <span class="st">'rui'</span>, <span class="st">'est'</span>, <span class="st">'details'</span>])</span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'Iu'</span>] <span class="op">=</span> df.uid.<span class="bu">apply</span>(get_Iu)</span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'Ui'</span>] <span class="op">=</span> df.iid.<span class="bu">apply</span>(get_Ui)</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>df[<span class="st">'err'</span>] <span class="op">=</span> <span class="bu">abs</span>(df.est <span class="op">-</span> df.rui)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d99cf3a5" class="cell">
<div class="sourceCode cell-code" id="cb107"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb107-1"><a href="#cb107-1" aria-hidden="true" tabindex="-1"></a>best_predictions <span class="op">=</span> df.sort_values(by<span class="op">=</span><span class="st">'err'</span>)[:<span class="dv">10</span>]</span>
<span id="cb107-2"><a href="#cb107-2" aria-hidden="true" tabindex="-1"></a>worst_predictions <span class="op">=</span> df.sort_values(by<span class="op">=</span><span class="st">'err'</span>)[<span class="op">-</span><span class="dv">10</span>:]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="5f23f256" class="cell">
<div class="sourceCode cell-code" id="cb108"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's take a look at the best predictions of the algorithm</span></span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a>best_predictions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d7d608a0" class="cell">
<div class="sourceCode cell-code" id="cb109"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>trainset_df.query(<span class="st">"song_id==154"</span>).user_id.nunique()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>|Ui| is always big</strong> (&gt; 86), meaning that many users have played the target song in the trainset. <strong>|Iu| is always very small</strong>, meaning that the target user have note played many songs in the trainset.</p>
<p>So it is easy to find users who have listened the song (as they are many), hence it is to find <strong>k</strong> users similar to the target user. And as they are similar to the target user, it is likely that they will rate the target song as the target user.</p>
<p><strong>So all these predictions make sens.</strong></p>
<div id="bea18830" class="cell">
<div class="sourceCode cell-code" id="cb110"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Now, let's look at the prediction with the biggest error</span></span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a>worst_predictions</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>|Ui| is always big</strong> (&gt; 86), meaning that many users have played the target song in the trainset. <strong>|Iu| is always very small</strong>, meaning that the target user have note played many songs in the trainset.</p>
<p>So it is easy to find users who have listened the song (as they are many), hence it is to find <strong>k</strong> users similar to the target user. And as they are similar to the target user, it is likely that they will rate the target song as the target user. But the predictions are not good. The explanation left is the taste of this song by this target is different from all his similar users.</p>
<p><strong>So all these predictions are not good because we are in the cases of biased users.</strong></p>
<p>These are situations where baseline estimates would be quite helpful, in order to deal with highly biased users (and items).</p>
<div id="257d8191" class="cell">
<div class="sourceCode cell-code" id="cb111"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib</span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a><span class="op">%</span>matplotlib inline</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>matplotlib.style.use(<span class="st">'ggplot'</span>)</span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>counter <span class="op">=</span> Counter([r <span class="cf">for</span> (_, r) <span class="kw">in</span> trainset.ir[trainset.to_inner_iid(<span class="dv">154</span>)]])</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>pd.DataFrame.from_dict(counter, orient<span class="op">=</span><span class="st">'index'</span>).plot(kind<span class="op">=</span><span class="st">'bar'</span>, legend<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Play count'</span>)</span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Number of users'</span>)</span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Number of users having played item 154'</span>)</span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As we can see in the above figure, most of the users played the song only once and very small number played the song 5 times and our target user is among them. So he is a biased user.</p>
<p><strong>We can build another model for those biased users. And combine the models to create an hybrid recommendation system.</strong></p>
</section>
<section id="customizing-the-knnbasic-algorithm" class="level2" data-number="9">
<h2 data-number="9" class="anchored" data-anchor-id="customizing-the-knnbasic-algorithm"><span class="header-section-number">9</span> Customizing the KNNBasic algorithm</h2>
<div id="aa62a4a3" class="cell">
<div class="sourceCode cell-code" id="cb112"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.prediction_algorithms.knns <span class="im">import</span> SymmetricAlgo</span>
<span id="cb112-2"><a href="#cb112-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-3"><a href="#cb112-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> surprise.prediction_algorithms.predictions <span class="im">import</span> PredictionImpossible</span>
<span id="cb112-4"><a href="#cb112-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.ensemble <span class="im">import</span> RandomForestRegressor</span>
<span id="cb112-5"><a href="#cb112-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-6"><a href="#cb112-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CollaborativeRandomForest(SymmetricAlgo):</span>
<span id="cb112-7"><a href="#cb112-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""A basic collaborative filtering algorithm.</span></span>
<span id="cb112-8"><a href="#cb112-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-9"><a href="#cb112-9" aria-hidden="true" tabindex="-1"></a><span class="co">    The prediction :math:`</span><span class="ch">\\</span><span class="co">hat{r}_{ui}` is set as:</span></span>
<span id="cb112-10"><a href="#cb112-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-11"><a href="#cb112-11" aria-hidden="true" tabindex="-1"></a><span class="co">    .. math::</span></span>
<span id="cb112-12"><a href="#cb112-12" aria-hidden="true" tabindex="-1"></a><span class="co">        </span><span class="ch">\\</span><span class="co">hat{r}_{ui} = </span><span class="ch">\\</span><span class="co">frac{</span></span>
<span id="cb112-13"><a href="#cb112-13" aria-hidden="true" tabindex="-1"></a><span class="co">        </span><span class="ch">\\</span><span class="co">sum</span><span class="ch">\\</span><span class="co">limits_{v </span><span class="ch">\\</span><span class="co">in N^k_i(u)} </span><span class="ch">\\</span><span class="co">text{sim}(u, v) </span><span class="ch">\\</span><span class="co">cdot r_{vi}}</span></span>
<span id="cb112-14"><a href="#cb112-14" aria-hidden="true" tabindex="-1"></a><span class="co">        {</span><span class="ch">\\</span><span class="co">sum</span><span class="ch">\\</span><span class="co">limits_{v </span><span class="ch">\\</span><span class="co">in N^k_i(u)} </span><span class="ch">\\</span><span class="co">text{sim}(u, v)}</span></span>
<span id="cb112-15"><a href="#cb112-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-16"><a href="#cb112-16" aria-hidden="true" tabindex="-1"></a><span class="co">    or</span></span>
<span id="cb112-17"><a href="#cb112-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-18"><a href="#cb112-18" aria-hidden="true" tabindex="-1"></a><span class="co">    .. math::</span></span>
<span id="cb112-19"><a href="#cb112-19" aria-hidden="true" tabindex="-1"></a><span class="co">        </span><span class="ch">\\</span><span class="co">hat{r}_{ui} = </span><span class="ch">\\</span><span class="co">frac{</span></span>
<span id="cb112-20"><a href="#cb112-20" aria-hidden="true" tabindex="-1"></a><span class="co">        </span><span class="ch">\\</span><span class="co">sum</span><span class="ch">\\</span><span class="co">limits_{j </span><span class="ch">\\</span><span class="co">in N^k_u(i)} </span><span class="ch">\\</span><span class="co">text{sim}(i, j) </span><span class="ch">\\</span><span class="co">cdot r_{uj}}</span></span>
<span id="cb112-21"><a href="#cb112-21" aria-hidden="true" tabindex="-1"></a><span class="co">        {</span><span class="ch">\\</span><span class="co">sum</span><span class="ch">\\</span><span class="co">limits_{j </span><span class="ch">\\</span><span class="co">in N^k_u(i)} </span><span class="ch">\\</span><span class="co">text{sim}(i, j)}</span></span>
<span id="cb112-22"><a href="#cb112-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-23"><a href="#cb112-23" aria-hidden="true" tabindex="-1"></a><span class="co">    depending on the ``user_based`` field of the ``sim_options`` parameter.</span></span>
<span id="cb112-24"><a href="#cb112-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-25"><a href="#cb112-25" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb112-26"><a href="#cb112-26" aria-hidden="true" tabindex="-1"></a><span class="co">        k(int): The (max) number of neighbors to take into account for</span></span>
<span id="cb112-27"><a href="#cb112-27" aria-hidden="true" tabindex="-1"></a><span class="co">            aggregation (see :ref:`this note &lt;actual_k_note&gt;`). Default is</span></span>
<span id="cb112-28"><a href="#cb112-28" aria-hidden="true" tabindex="-1"></a><span class="co">            ``40``.</span></span>
<span id="cb112-29"><a href="#cb112-29" aria-hidden="true" tabindex="-1"></a><span class="co">        min_k(int): The minimum number of neighbors to take into account for</span></span>
<span id="cb112-30"><a href="#cb112-30" aria-hidden="true" tabindex="-1"></a><span class="co">            aggregation. If there are not enough neighbors, the prediction is</span></span>
<span id="cb112-31"><a href="#cb112-31" aria-hidden="true" tabindex="-1"></a><span class="co">            set to the global mean of all ratings. Default is ``1``.</span></span>
<span id="cb112-32"><a href="#cb112-32" aria-hidden="true" tabindex="-1"></a><span class="co">        sim_options(dict): A dictionary of options for the similarity</span></span>
<span id="cb112-33"><a href="#cb112-33" aria-hidden="true" tabindex="-1"></a><span class="co">            measure. See :ref:`similarity_measures_configuration` for accepted</span></span>
<span id="cb112-34"><a href="#cb112-34" aria-hidden="true" tabindex="-1"></a><span class="co">            options.</span></span>
<span id="cb112-35"><a href="#cb112-35" aria-hidden="true" tabindex="-1"></a><span class="co">        verbose(bool): Whether to print trace messages of bias estimation,</span></span>
<span id="cb112-36"><a href="#cb112-36" aria-hidden="true" tabindex="-1"></a><span class="co">            similarity, etc.  Default is True.</span></span>
<span id="cb112-37"><a href="#cb112-37" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb112-38"><a href="#cb112-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-39"><a href="#cb112-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, k<span class="op">=</span><span class="dv">40</span>, min_k<span class="op">=</span><span class="dv">1</span>, sim_options<span class="op">=</span>{}, verbose<span class="op">=</span><span class="va">True</span>, <span class="op">**</span>kwargs):</span>
<span id="cb112-40"><a href="#cb112-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-41"><a href="#cb112-41" aria-hidden="true" tabindex="-1"></a>        SymmetricAlgo.<span class="fu">__init__</span>(<span class="va">self</span>, sim_options<span class="op">=</span>sim_options, verbose<span class="op">=</span>verbose, <span class="op">**</span>kwargs)</span>
<span id="cb112-42"><a href="#cb112-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.k <span class="op">=</span> k</span>
<span id="cb112-43"><a href="#cb112-43" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.min_k <span class="op">=</span> min_k</span>
<span id="cb112-44"><a href="#cb112-44" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.rf <span class="op">=</span> RandomForestRegressor()</span>
<span id="cb112-45"><a href="#cb112-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-46"><a href="#cb112-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> compute_rating_and_sim_averages(<span class="va">self</span>, neighbors):</span>
<span id="cb112-47"><a href="#cb112-47" aria-hidden="true" tabindex="-1"></a>        <span class="co"># compute weighted average</span></span>
<span id="cb112-48"><a href="#cb112-48" aria-hidden="true" tabindex="-1"></a>        sum_sim <span class="op">=</span> sum_ratings <span class="op">=</span> actual_k <span class="op">=</span> rating <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb112-49"><a href="#cb112-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (<span class="bu">len</span>(neighbors) <span class="op">!=</span> <span class="dv">0</span>):</span>
<span id="cb112-50"><a href="#cb112-50" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> (sim, r) <span class="kw">in</span> neighbors:</span>
<span id="cb112-51"><a href="#cb112-51" aria-hidden="true" tabindex="-1"></a>              sum_sim <span class="op">+=</span> sim</span>
<span id="cb112-52"><a href="#cb112-52" aria-hidden="true" tabindex="-1"></a>              sum_ratings <span class="op">+=</span> sim <span class="op">*</span> r</span>
<span id="cb112-53"><a href="#cb112-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb112-54"><a href="#cb112-54" aria-hidden="true" tabindex="-1"></a>            rating <span class="op">=</span> <span class="va">self</span>.trainset.global_mean</span>
<span id="cb112-55"><a href="#cb112-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-56"><a href="#cb112-56" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> sum_sim <span class="op">!=</span> <span class="dv">0</span> :</span>
<span id="cb112-57"><a href="#cb112-57" aria-hidden="true" tabindex="-1"></a>              rating <span class="op">=</span> sum_ratings<span class="op">/</span>sum_sim</span>
<span id="cb112-58"><a href="#cb112-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (sum_sim, rating)</span>
<span id="cb112-59"><a href="#cb112-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-60"><a href="#cb112-60" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> fit(<span class="va">self</span>, trainset):</span>
<span id="cb112-61"><a href="#cb112-61" aria-hidden="true" tabindex="-1"></a>        SymmetricAlgo.fit(<span class="va">self</span>, trainset)</span>
<span id="cb112-62"><a href="#cb112-62" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.sim <span class="op">=</span> <span class="va">self</span>.compute_similarities()</span>
<span id="cb112-63"><a href="#cb112-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-64"><a href="#cb112-64" aria-hidden="true" tabindex="-1"></a>        <span class="co">#The feature matrix</span></span>
<span id="cb112-65"><a href="#cb112-65" aria-hidden="true" tabindex="-1"></a>          <span class="co"># an observation in x is the wheighted average of similarities for each user.</span></span>
<span id="cb112-66"><a href="#cb112-66" aria-hidden="true" tabindex="-1"></a>          <span class="co"># For each user we compute the wheighted average of the similarities</span></span>
<span id="cb112-67"><a href="#cb112-67" aria-hidden="true" tabindex="-1"></a>          <span class="co"># of all the users who listened to a target song for all the songs in the training dataset</span></span>
<span id="cb112-68"><a href="#cb112-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-69"><a href="#cb112-69" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> []</span>
<span id="cb112-70"><a href="#cb112-70" aria-hidden="true" tabindex="-1"></a>        <span class="co">#The target, the play counts</span></span>
<span id="cb112-71"><a href="#cb112-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-72"><a href="#cb112-72" aria-hidden="true" tabindex="-1"></a>        Y <span class="op">=</span> []</span>
<span id="cb112-73"><a href="#cb112-73" aria-hidden="true" tabindex="-1"></a>        <span class="co"># an observation in Y is the wheighted average of play counts for each user.</span></span>
<span id="cb112-74"><a href="#cb112-74" aria-hidden="true" tabindex="-1"></a>          <span class="co"># For each user we compute the wheighted average of the play counts</span></span>
<span id="cb112-75"><a href="#cb112-75" aria-hidden="true" tabindex="-1"></a>          <span class="co"># of all the users who listened to a target song for all the songs in the training dataset</span></span>
<span id="cb112-76"><a href="#cb112-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> u <span class="kw">in</span> trainset.all_users():</span>
<span id="cb112-77"><a href="#cb112-77" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span> i <span class="kw">in</span> trainset.all_items():</span>
<span id="cb112-78"><a href="#cb112-78" aria-hidden="true" tabindex="-1"></a>            x, y <span class="op">=</span> <span class="va">self</span>.switch(u, i)</span>
<span id="cb112-79"><a href="#cb112-79" aria-hidden="true" tabindex="-1"></a>            neighbors <span class="op">=</span> [(<span class="va">self</span>.sim[x, x2], r) <span class="cf">for</span> (x2, r) <span class="kw">in</span> <span class="va">self</span>.yr[y]]</span>
<span id="cb112-80"><a href="#cb112-80" aria-hidden="true" tabindex="-1"></a>            n <span class="op">=</span> <span class="va">self</span>.compute_rating_and_sim_averages(neighbors)</span>
<span id="cb112-81"><a href="#cb112-81" aria-hidden="true" tabindex="-1"></a>            X.append(n[<span class="dv">0</span>])</span>
<span id="cb112-82"><a href="#cb112-82" aria-hidden="true" tabindex="-1"></a>            Y.append(n[<span class="dv">1</span>])</span>
<span id="cb112-83"><a href="#cb112-83" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-84"><a href="#cb112-84" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.rf.fit(np.array(X).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), Y)</span>
<span id="cb112-85"><a href="#cb112-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-86"><a href="#cb112-86" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span></span>
<span id="cb112-87"><a href="#cb112-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-88"><a href="#cb112-88" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> estimate(<span class="va">self</span>, u, i):</span>
<span id="cb112-89"><a href="#cb112-89" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> (<span class="va">self</span>.trainset.knows_user(u) <span class="kw">and</span> <span class="va">self</span>.trainset.knows_item(i)):</span>
<span id="cb112-90"><a href="#cb112-90" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> PredictionImpossible(<span class="st">"User and/or item is unknown."</span>)</span>
<span id="cb112-91"><a href="#cb112-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-92"><a href="#cb112-92" aria-hidden="true" tabindex="-1"></a>        x, y <span class="op">=</span> <span class="va">self</span>.switch(u, i)</span>
<span id="cb112-93"><a href="#cb112-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-94"><a href="#cb112-94" aria-hidden="true" tabindex="-1"></a>        neighbors <span class="op">=</span> [(<span class="va">self</span>.sim[x, x2], r) <span class="cf">for</span> (x2, r) <span class="kw">in</span> <span class="va">self</span>.yr[y]]</span>
<span id="cb112-95"><a href="#cb112-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-96"><a href="#cb112-96" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="va">self</span>.compute_rating_and_sim_averages(neighbors)[<span class="dv">0</span>]</span>
<span id="cb112-97"><a href="#cb112-97" aria-hidden="true" tabindex="-1"></a>        est <span class="op">=</span> <span class="va">self</span>.rf.predict(np.array(n).reshape(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))[<span class="dv">0</span>]</span>
<span id="cb112-98"><a href="#cb112-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb112-99"><a href="#cb112-99" aria-hidden="true" tabindex="-1"></a>        details <span class="op">=</span> {<span class="st">"actual_k"</span>: <span class="dv">6</span>}</span>
<span id="cb112-100"><a href="#cb112-100" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> est, details</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="ef893a9c" class="cell">
<div class="sourceCode cell-code" id="cb113"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build the default KNNBasicWithRandomForest model</span></span>
<span id="cb113-2"><a href="#cb113-2" aria-hidden="true" tabindex="-1"></a>sim_options<span class="op">=</span><span class="bu">dict</span>(name<span class="op">=</span><span class="st">'cosine'</span>, user_based<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb113-3"><a href="#cb113-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-4"><a href="#cb113-4" aria-hidden="true" tabindex="-1"></a><span class="co"># KNN algorithm is used to find desired similar items</span></span>
<span id="cb113-5"><a href="#cb113-5" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use random_state = 1</span></span>
<span id="cb113-6"><a href="#cb113-6" aria-hidden="true" tabindex="-1"></a>sim_user_user_model <span class="op">=</span> CollaborativeRandomForest(sim_options<span class="op">=</span>sim_options,</span>
<span id="cb113-7"><a href="#cb113-7" aria-hidden="true" tabindex="-1"></a>                                               random_state<span class="op">=</span><span class="dv">1</span>, verbose<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb113-8"><a href="#cb113-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-9"><a href="#cb113-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Train the algorithm on the trainset, and predict play_count for the testset</span></span>
<span id="cb113-10"><a href="#cb113-10" aria-hidden="true" tabindex="-1"></a>sim_user_user_model.fit(trainset)</span>
<span id="cb113-11"><a href="#cb113-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb113-12"><a href="#cb113-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Let us compute precision@k, recall@k, and f_1 score with k = 30</span></span>
<span id="cb113-13"><a href="#cb113-13" aria-hidden="true" tabindex="-1"></a> <span class="co"># Use sim_user_user model</span></span>
<span id="cb113-14"><a href="#cb113-14" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k(sim_user_user_model, threshold<span class="op">=</span><span class="fl">1.5</span>, testset<span class="op">=</span>testset)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The F1 score is still 0.66. So there is no improvement.</p>
<p>The performance of this model is not high. This is because we are using only one future, the weighted similarities. This is comparable to predicting the skin color of a person based on his age, it doesn’t make much sense.</p>
</section>
<section id="building-an-hybrid-recommendation-system" class="level2" data-number="10">
<h2 data-number="10" class="anchored" data-anchor-id="building-an-hybrid-recommendation-system"><span class="header-section-number">10</span> Building an hybrid recommendation system:</h2>
<ul>
<li>We will use LightFM a newly discovered library</li>
</ul>
<div id="3c419522" class="cell">
<div class="sourceCode cell-code" id="cb114"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Installing lightfm</span></span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a><span class="op">!</span>pip install lightfm</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="2da23fc2" class="cell">
<div class="sourceCode cell-code" id="cb115"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Importing packages</span></span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lightfm <span class="im">import</span> LightFM</span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lightfm.data <span class="im">import</span> Dataset</span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lightfm.evaluation <span class="im">import</span> precision_at_k, recall_at_k, auc_score</span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> lightfm.cross_validation <span class="im">import</span> random_train_test_split</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="434e3e3a" class="cell">
<div class="sourceCode cell-code" id="cb116"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Modifying the dataset cutoffs thresholds</span></span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the column containing the users</span></span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df_copy</span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a>users <span class="op">=</span> df.user_id</span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dictionary that maps users(listeners) to the number of songs that they have listened to</span></span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>playing_count <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> user <span class="kw">in</span> users:</span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we already have the user, just add 1 to their playing count</span></span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> user <span class="kw">in</span> playing_count:</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a>        playing_count[user] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Otherwise, set their playing count to 1</span></span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>        playing_count[user] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a><span class="co"># We want our users to have listened at least 90 songs</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a>SONG_COUNT_CUTOFF <span class="op">=</span> <span class="dv">90</span></span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a list of users who need to be removed</span></span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a>remove_users <span class="op">=</span> []</span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> user, num_songs <span class="kw">in</span> playing_count.items():</span>
<span id="cb116-25"><a href="#cb116-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-26"><a href="#cb116-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_songs <span class="op">&lt;</span> SONG_COUNT_CUTOFF:</span>
<span id="cb116-27"><a href="#cb116-27" aria-hidden="true" tabindex="-1"></a>        remove_users.append(user)</span>
<span id="cb116-28"><a href="#cb116-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-29"><a href="#cb116-29" aria-hidden="true" tabindex="-1"></a>df <span class="op">=</span> df.loc[ <span class="op">~</span> df.user_id.isin(remove_users)]</span>
<span id="cb116-30"><a href="#cb116-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-31"><a href="#cb116-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-32"><a href="#cb116-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Get the column containing the songs</span></span>
<span id="cb116-33"><a href="#cb116-33" aria-hidden="true" tabindex="-1"></a>songs <span class="op">=</span> df.song_id</span>
<span id="cb116-34"><a href="#cb116-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-35"><a href="#cb116-35" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a dictionary that maps songs to its number of users(listeners)</span></span>
<span id="cb116-36"><a href="#cb116-36" aria-hidden="true" tabindex="-1"></a>playing_count <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb116-37"><a href="#cb116-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-38"><a href="#cb116-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> song <span class="kw">in</span> songs:</span>
<span id="cb116-39"><a href="#cb116-39" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we already have the song, just add 1 to their playing count</span></span>
<span id="cb116-40"><a href="#cb116-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> song <span class="kw">in</span> playing_count:</span>
<span id="cb116-41"><a href="#cb116-41" aria-hidden="true" tabindex="-1"></a>        playing_count[song] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb116-42"><a href="#cb116-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-43"><a href="#cb116-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Otherwise, set their playing count to 1</span></span>
<span id="cb116-44"><a href="#cb116-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb116-45"><a href="#cb116-45" aria-hidden="true" tabindex="-1"></a>        playing_count[song] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb116-46"><a href="#cb116-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-47"><a href="#cb116-47" aria-hidden="true" tabindex="-1"></a><span class="co"># We want our song to be listened by at least 120 users to be considred</span></span>
<span id="cb116-48"><a href="#cb116-48" aria-hidden="true" tabindex="-1"></a>LISTENER_COUNT_CUTOFF <span class="op">=</span> <span class="dv">120</span></span>
<span id="cb116-49"><a href="#cb116-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-50"><a href="#cb116-50" aria-hidden="true" tabindex="-1"></a>remove_songs <span class="op">=</span> []</span>
<span id="cb116-51"><a href="#cb116-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-52"><a href="#cb116-52" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> song, num_users <span class="kw">in</span> playing_count.items():</span>
<span id="cb116-53"><a href="#cb116-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> num_users <span class="op">&lt;</span> LISTENER_COUNT_CUTOFF:</span>
<span id="cb116-54"><a href="#cb116-54" aria-hidden="true" tabindex="-1"></a>        remove_songs.append(song)</span>
<span id="cb116-55"><a href="#cb116-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-56"><a href="#cb116-56" aria-hidden="true" tabindex="-1"></a>df_final <span class="op">=</span> df.loc[ <span class="op">~</span> df.song_id.isin(remove_songs)]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="8c7fef6d" class="cell">
<div class="sourceCode cell-code" id="cb117"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Caping the play count to 5</span></span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>df_final.loc[df_final.play_count<span class="op">&gt;</span><span class="dv">5</span>, <span class="st">'play_count'</span>] <span class="op">=</span> <span class="dv">5</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="61884988" class="cell">
<div class="sourceCode cell-code" id="cb118"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a><span class="co"># rescaling the playcount [0, 1]</span></span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>df_final[<span class="st">'play_count_scaled'</span>] <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span> df_final.play_count</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="9cb13ce7" class="cell">
<div class="sourceCode cell-code" id="cb119"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting desired positive pairs (playcount&gt;1.5 or play_count_scaled&gt;0.3 ) to 1</span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="co"># and negatives pairs to 0</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a>df_final.loc[df_final[<span class="st">'play_count_scaled'</span>] <span class="op">&lt;</span> <span class="fl">0.3</span>, <span class="st">'play_count_scaled'</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>df_final.loc[df_final[<span class="st">'play_count_scaled'</span>] <span class="op">&gt;=</span> <span class="fl">0.3</span>, <span class="st">'play_count_scaled'</span>] <span class="op">=</span> <span class="dv">1</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f4f988cc" class="cell">
<div class="sourceCode cell-code" id="cb120"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Defining users and songs sets</span></span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>user_ids <span class="op">=</span> <span class="bu">set</span>(df_final.user_id)</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a>songs_ids <span class="op">=</span> <span class="bu">set</span>(df_final.song_id)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="113ce408" class="cell">
<div class="sourceCode cell-code" id="cb121"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Defining user features</span></span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a>nbr_user_listened_songs <span class="op">=</span> df_final.groupby(<span class="st">'user_id'</span>).play_count.count()</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a>nbr_user_listened_songs <span class="op">=</span> nbr_user_listened_songs <span class="op">/</span> nbr_user_listened_songs.values.<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="f7724d71" class="cell">
<div class="sourceCode cell-code" id="cb122"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Defining songs features</span></span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>df_final[<span class="st">'text'</span>] <span class="op">=</span> df_final[<span class="st">'title'</span>] <span class="op">+</span> <span class="st">' '</span> <span class="op">+</span> df_final[<span class="st">'release'</span>] <span class="op">+</span> <span class="st">' '</span> <span class="op">+</span>  df_final[<span class="st">'artist_name'</span>]</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="d09cfe64" class="cell">
<div class="sourceCode cell-code" id="cb123"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a Dataset object and fit users, songs, and features</span></span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> Dataset()</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>dataset.fit(users<span class="op">=</span>user_ids,</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>            items<span class="op">=</span>songs_ids,</span>
<span id="cb123-5"><a href="#cb123-5" aria-hidden="true" tabindex="-1"></a>            user_features <span class="op">=</span> <span class="bu">set</span>(nbr_user_listened_songs),</span>
<span id="cb123-6"><a href="#cb123-6" aria-hidden="true" tabindex="-1"></a>            item_features <span class="op">=</span> <span class="bu">set</span>(df_final.text))</span>
<span id="cb123-7"><a href="#cb123-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-8"><a href="#cb123-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb123-9"><a href="#cb123-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Build interactions and features</span></span>
<span id="cb123-10"><a href="#cb123-10" aria-hidden="true" tabindex="-1"></a>interactions <span class="op">=</span> [(x[<span class="dv">0</span>], x[<span class="dv">1</span>], x[<span class="dv">2</span>]) <span class="cf">for</span> x <span class="kw">in</span> df_final[[<span class="st">'user_id'</span>, <span class="st">'song_id'</span>, <span class="st">'play_count_scaled'</span>]].values]</span>
<span id="cb123-11"><a href="#cb123-11" aria-hidden="true" tabindex="-1"></a>(interactions, weights) <span class="op">=</span> dataset.build_interactions(interactions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="63f1d2a4" class="cell">
<div class="sourceCode cell-code" id="cb124"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Split the interactions matrix into a train and test set</span></span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>test_ratio <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>train_interactions, test_interactions <span class="op">=</span> random_train_test_split(interactions, test_percentage<span class="op">=</span>test_ratio, random_state<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>train_weights, test_weights <span class="op">=</span> random_train_test_split(weights, test_percentage<span class="op">=</span>test_ratio, random_state<span class="op">=</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="79e0aa12" class="cell">
<div class="sourceCode cell-code" id="cb125"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Builiding user features</span></span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>user_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(nbr_user_listened_songs.index, nbr_user_listened_songs.<span class="bu">apply</span>(<span class="kw">lambda</span> x: [x])))</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>user_features <span class="op">=</span> dataset.build_user_features(user_features)</span>
<span id="cb125-4"><a href="#cb125-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-5"><a href="#cb125-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb125-6"><a href="#cb125-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Builiding items features</span></span>
<span id="cb125-7"><a href="#cb125-7" aria-hidden="true" tabindex="-1"></a>item_features <span class="op">=</span> <span class="bu">list</span>((x[<span class="dv">0</span>], [x[<span class="dv">1</span>]]) <span class="cf">for</span> x <span class="kw">in</span> df_final[[<span class="st">'song_id'</span>, <span class="st">'text'</span>]].drop_duplicates().values)</span>
<span id="cb125-8"><a href="#cb125-8" aria-hidden="true" tabindex="-1"></a>item_features <span class="op">=</span> dataset.build_item_features(item_features)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="674db499" class="cell">
<div class="sourceCode cell-code" id="cb126"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Creating the LightFM model</span></span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>basic_lfm <span class="op">=</span> LightFM(</span>
<span id="cb126-3"><a href="#cb126-3" aria-hidden="true" tabindex="-1"></a>    no_components<span class="op">=</span><span class="dv">150</span>,</span>
<span id="cb126-4"><a href="#cb126-4" aria-hidden="true" tabindex="-1"></a>    learning_rate<span class="op">=</span><span class="fl">0.05</span>,</span>
<span id="cb126-5"><a href="#cb126-5" aria-hidden="true" tabindex="-1"></a>    loss<span class="op">=</span><span class="st">'warp'</span>,</span>
<span id="cb126-6"><a href="#cb126-6" aria-hidden="true" tabindex="-1"></a>    item_alpha<span class="op">=</span><span class="fl">0.0001</span>,</span>
<span id="cb126-7"><a href="#cb126-7" aria-hidden="true" tabindex="-1"></a>    user_alpha<span class="op">=</span><span class="fl">0.0001</span>,</span>
<span id="cb126-8"><a href="#cb126-8" aria-hidden="true" tabindex="-1"></a>    random_state<span class="op">=</span><span class="dv">200</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="55ed6db7" class="cell">
<div class="sourceCode cell-code" id="cb127"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Training the model</span></span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>basic_lfm.fit(train_interactions,</span>
<span id="cb127-3"><a href="#cb127-3" aria-hidden="true" tabindex="-1"></a>          sample_weight<span class="op">=</span>train_weights,</span>
<span id="cb127-4"><a href="#cb127-4" aria-hidden="true" tabindex="-1"></a>          user_features<span class="op">=</span>user_features,</span>
<span id="cb127-5"><a href="#cb127-5" aria-hidden="true" tabindex="-1"></a>          item_features<span class="op">=</span>item_features,</span>
<span id="cb127-6"><a href="#cb127-6" aria-hidden="true" tabindex="-1"></a>          epochs<span class="op">=</span><span class="dv">50</span>, num_threads<span class="op">=</span><span class="dv">50</span>, verbose<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="3baaf9a8" class="cell">
<div class="sourceCode cell-code" id="cb128"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="co"># A function to evaluate the model using LightFm evaluation metrics</span></span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> evaluate_lfm_model(model, test_interactions, user_features, item_features,</span>
<span id="cb128-3"><a href="#cb128-3" aria-hidden="true" tabindex="-1"></a>                       k<span class="op">=</span><span class="dv">30</span>):</span>
<span id="cb128-4"><a href="#cb128-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># compute the auc</span></span>
<span id="cb128-5"><a href="#cb128-5" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">'AUC'</span>, np.nanmean(auc_score(model,</span>
<span id="cb128-6"><a href="#cb128-6" aria-hidden="true" tabindex="-1"></a>                                    test_interactions,</span>
<span id="cb128-7"><a href="#cb128-7" aria-hidden="true" tabindex="-1"></a>                                    user_features<span class="op">=</span>user_features,</span>
<span id="cb128-8"><a href="#cb128-8" aria-hidden="true" tabindex="-1"></a>                                    item_features<span class="op">=</span>item_features)))</span>
<span id="cb128-9"><a href="#cb128-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calculate precision_at_k</span></span>
<span id="cb128-10"><a href="#cb128-10" aria-hidden="true" tabindex="-1"></a>  precision <span class="op">=</span> precision_at_k(model,</span>
<span id="cb128-11"><a href="#cb128-11" aria-hidden="true" tabindex="-1"></a>                                  test_interactions,</span>
<span id="cb128-12"><a href="#cb128-12" aria-hidden="true" tabindex="-1"></a>                                  user_features<span class="op">=</span>user_features,</span>
<span id="cb128-13"><a href="#cb128-13" aria-hidden="true" tabindex="-1"></a>                                  item_features<span class="op">=</span>item_features,</span>
<span id="cb128-14"><a href="#cb128-14" aria-hidden="true" tabindex="-1"></a>                                  k<span class="op">=</span>k</span>
<span id="cb128-15"><a href="#cb128-15" aria-hidden="true" tabindex="-1"></a>                                  ).mean()</span>
<span id="cb128-16"><a href="#cb128-16" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"Precision:"</span>, precision)</span>
<span id="cb128-17"><a href="#cb128-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-18"><a href="#cb128-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-19"><a href="#cb128-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># calculate recall_at_k</span></span>
<span id="cb128-20"><a href="#cb128-20" aria-hidden="true" tabindex="-1"></a>  recall <span class="op">=</span> recall_at_k(model,</span>
<span id="cb128-21"><a href="#cb128-21" aria-hidden="true" tabindex="-1"></a>                            test_interactions,</span>
<span id="cb128-22"><a href="#cb128-22" aria-hidden="true" tabindex="-1"></a>                            user_features<span class="op">=</span>user_features,</span>
<span id="cb128-23"><a href="#cb128-23" aria-hidden="true" tabindex="-1"></a>                            item_features<span class="op">=</span>item_features,</span>
<span id="cb128-24"><a href="#cb128-24" aria-hidden="true" tabindex="-1"></a>                            k<span class="op">=</span>k).mean()</span>
<span id="cb128-25"><a href="#cb128-25" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"Recall:"</span>, recall)</span>
<span id="cb128-26"><a href="#cb128-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb128-27"><a href="#cb128-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Calculate f1_score_at_k</span></span>
<span id="cb128-28"><a href="#cb128-28" aria-hidden="true" tabindex="-1"></a>  f1_score <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> precision <span class="op">*</span> recall <span class="op">/</span> (recall <span class="op">+</span> precision)</span>
<span id="cb128-29"><a href="#cb128-29" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="st">"F1_score:"</span>, f1_score)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="3632d357" class="cell">
<div class="sourceCode cell-code" id="cb129"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluating the performance of the model using lightfm evaluation metrics</span></span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>evaluate_lfm_model(basic_lfm, test_interactions, user_features,</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>                   item_features, <span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The AUC is 0.76. It measures the probability that a randomly chosen positive interaction (e.g., a user liking a song) is ranked higher by the model than a randomly chosen negative interaction (e.g., a user not liking a song)</p>
<section id="lets-evaluate-the-performance-of-the-model-with-a-threshold-in-surprise-library-manner" class="level3" data-number="10.1">
<h3 data-number="10.1" class="anchored" data-anchor-id="lets-evaluate-the-performance-of-the-model-with-a-threshold-in-surprise-library-manner"><span class="header-section-number">10.1</span> Let’s evaluate the performance of the model with a threshold in Surprise library manner</h3>
<div id="37f0f45d" class="cell">
<div class="sourceCode cell-code" id="cb130"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluating the model in an explicit feedback manner</span></span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's get the predictions and actual playcount for every user-song pair in the testset</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_predictions(model, df_final, dataset, test_interactions):</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Get the mappings</span></span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a>  user_id_mapping, user_feature_mapping, item_id_mapping, item_feature_mapping <span class="op">=</span> dataset.mapping()</span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create reverse mappings</span></span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a>  reverse_user_id_mapping <span class="op">=</span> {v: k <span class="cf">for</span> k, v <span class="kw">in</span> user_id_mapping.items()}</span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>  reverse_item_id_mapping <span class="op">=</span> {v: k <span class="cf">for</span> k, v <span class="kw">in</span> item_id_mapping.items()}</span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-12"><a href="#cb130-12" aria-hidden="true" tabindex="-1"></a>  df_interactions <span class="op">=</span> df_final[[<span class="st">'user_id'</span>, <span class="st">'song_id'</span>, <span class="st">'play_count_scaled'</span>]]</span>
<span id="cb130-13"><a href="#cb130-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-14"><a href="#cb130-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Function to get real ratings using internal IDs</span></span>
<span id="cb130-15"><a href="#cb130-15" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> get_real_rating(internal_user_id, internal_item_id, real_user_id <span class="op">=</span> <span class="va">None</span>,</span>
<span id="cb130-16"><a href="#cb130-16" aria-hidden="true" tabindex="-1"></a>                      real_item_id <span class="op">=</span> <span class="va">None</span>):</span>
<span id="cb130-17"><a href="#cb130-17" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="kw">not</span> real_user_id:</span>
<span id="cb130-18"><a href="#cb130-18" aria-hidden="true" tabindex="-1"></a>        real_user_id <span class="op">=</span> reverse_user_id_mapping.get(internal_user_id, <span class="va">None</span>)</span>
<span id="cb130-19"><a href="#cb130-19" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> <span class="kw">not</span> real_item_id:</span>
<span id="cb130-20"><a href="#cb130-20" aria-hidden="true" tabindex="-1"></a>        real_item_id <span class="op">=</span> reverse_item_id_mapping.get(internal_item_id, <span class="va">None</span>)</span>
<span id="cb130-21"><a href="#cb130-21" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> real_user_id <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="kw">and</span> real_item_id <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb130-22"><a href="#cb130-22" aria-hidden="true" tabindex="-1"></a>          rating <span class="op">=</span> df_interactions.loc[</span>
<span id="cb130-23"><a href="#cb130-23" aria-hidden="true" tabindex="-1"></a>              (df_interactions[<span class="st">'user_id'</span>] <span class="op">==</span> real_user_id) <span class="op">&amp;</span></span>
<span id="cb130-24"><a href="#cb130-24" aria-hidden="true" tabindex="-1"></a>              (df_interactions[<span class="st">'song_id'</span>] <span class="op">==</span> real_item_id), <span class="st">'play_count_scaled'</span>]</span>
<span id="cb130-25"><a href="#cb130-25" aria-hidden="true" tabindex="-1"></a>          <span class="cf">if</span> <span class="kw">not</span> rating.empty:</span>
<span id="cb130-26"><a href="#cb130-26" aria-hidden="true" tabindex="-1"></a>              <span class="cf">return</span> rating.values[<span class="dv">0</span>]</span>
<span id="cb130-27"><a href="#cb130-27" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="va">None</span></span>
<span id="cb130-28"><a href="#cb130-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-29"><a href="#cb130-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-30"><a href="#cb130-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Function to get real user_id and item_id</span></span>
<span id="cb130-31"><a href="#cb130-31" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> get_real_ids(internal_user_id, internal_item_id):</span>
<span id="cb130-32"><a href="#cb130-32" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Reverse the user_id_mapping and item_id_mapping to map internal IDs to real IDs</span></span>
<span id="cb130-33"><a href="#cb130-33" aria-hidden="true" tabindex="-1"></a>      real_user_id <span class="op">=</span> {v: k <span class="cf">for</span> k, v <span class="kw">in</span> user_id_mapping.items()}[internal_user_id]</span>
<span id="cb130-34"><a href="#cb130-34" aria-hidden="true" tabindex="-1"></a>      real_item_id <span class="op">=</span> {v: k <span class="cf">for</span> k, v <span class="kw">in</span> item_id_mapping.items()}[internal_item_id]</span>
<span id="cb130-35"><a href="#cb130-35" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> real_user_id, real_item_id</span>
<span id="cb130-36"><a href="#cb130-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-37"><a href="#cb130-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-38"><a href="#cb130-38" aria-hidden="true" tabindex="-1"></a>  user_song_pairs <span class="op">=</span> test_interactions.nonzero()</span>
<span id="cb130-39"><a href="#cb130-39" aria-hidden="true" tabindex="-1"></a>  user_and_song_iternal_ids <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(user_song_pairs[<span class="dv">0</span>], user_song_pairs[<span class="dv">1</span>]))</span>
<span id="cb130-40"><a href="#cb130-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-41"><a href="#cb130-41" aria-hidden="true" tabindex="-1"></a>  ests <span class="op">=</span> []</span>
<span id="cb130-42"><a href="#cb130-42" aria-hidden="true" tabindex="-1"></a>  trues <span class="op">=</span> []</span>
<span id="cb130-43"><a href="#cb130-43" aria-hidden="true" tabindex="-1"></a>  user_est_true_lfm <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb130-44"><a href="#cb130-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> iternal_user, internal_song <span class="kw">in</span> user_and_song_iternal_ids:</span>
<span id="cb130-45"><a href="#cb130-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-46"><a href="#cb130-46" aria-hidden="true" tabindex="-1"></a>    real_user_id, real_item_id <span class="op">=</span> get_real_ids(iternal_user, internal_song)</span>
<span id="cb130-47"><a href="#cb130-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-48"><a href="#cb130-48" aria-hidden="true" tabindex="-1"></a>    score <span class="op">=</span> model.predict(<span class="bu">int</span>(iternal_user), [<span class="bu">int</span>(internal_song)])[<span class="dv">0</span>]</span>
<span id="cb130-49"><a href="#cb130-49" aria-hidden="true" tabindex="-1"></a>    playcount <span class="op">=</span> get_real_rating(iternal_user, internal_song, real_user_id, real_item_id)</span>
<span id="cb130-50"><a href="#cb130-50" aria-hidden="true" tabindex="-1"></a>    user_est_true_lfm[real_user_id].append((score, playcount))</span>
<span id="cb130-51"><a href="#cb130-51" aria-hidden="true" tabindex="-1"></a>    ests.append(score)</span>
<span id="cb130-52"><a href="#cb130-52" aria-hidden="true" tabindex="-1"></a>    trues.append(playcount)</span>
<span id="cb130-53"><a href="#cb130-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-54"><a href="#cb130-54" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> user_est_true_lfm, ests, trues</span>
<span id="cb130-55"><a href="#cb130-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-56"><a href="#cb130-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-57"><a href="#cb130-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-58"><a href="#cb130-58" aria-hidden="true" tabindex="-1"></a><span class="co"># Let's customize the precision_recall_at_k function</span></span>
<span id="cb130-59"><a href="#cb130-59" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> precision_recall_at_k_lfm(k<span class="op">=</span><span class="dv">30</span>, threshold<span class="op">=</span><span class="dv">0</span>, user_est_true<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb130-60"><a href="#cb130-60" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Return precision and recall at k metrics for each user"""</span></span>
<span id="cb130-61"><a href="#cb130-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-62"><a href="#cb130-62" aria-hidden="true" tabindex="-1"></a>    precisions <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb130-63"><a href="#cb130-63" aria-hidden="true" tabindex="-1"></a>    recalls <span class="op">=</span> <span class="bu">dict</span>()</span>
<span id="cb130-64"><a href="#cb130-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-65"><a href="#cb130-65" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> uid, playing_count <span class="kw">in</span> user_est_true.items():</span>
<span id="cb130-66"><a href="#cb130-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-67"><a href="#cb130-67" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sort play count by estimated value</span></span>
<span id="cb130-68"><a href="#cb130-68" aria-hidden="true" tabindex="-1"></a>        playing_count.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb130-69"><a href="#cb130-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-70"><a href="#cb130-70" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Number of relevant items</span></span>
<span id="cb130-71"><a href="#cb130-71" aria-hidden="true" tabindex="-1"></a>        n_rel <span class="op">=</span> <span class="bu">sum</span>((true_r <span class="op">&gt;=</span> threshold) <span class="cf">for</span> (_, true_r) <span class="kw">in</span> playing_count)</span>
<span id="cb130-72"><a href="#cb130-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-73"><a href="#cb130-73" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Number of recommended items in top k</span></span>
<span id="cb130-74"><a href="#cb130-74" aria-hidden="true" tabindex="-1"></a>        n_rec_k <span class="op">=</span> <span class="bu">sum</span>((est <span class="op">&gt;=</span> threshold) <span class="cf">for</span> (est, _) <span class="kw">in</span> playing_count[:k])</span>
<span id="cb130-75"><a href="#cb130-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-76"><a href="#cb130-76" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Number of relevant and recommended items in top k</span></span>
<span id="cb130-77"><a href="#cb130-77" aria-hidden="true" tabindex="-1"></a>        n_rel_and_rec_k <span class="op">=</span> <span class="bu">sum</span>(((true_r <span class="op">&gt;=</span> threshold) <span class="kw">and</span> (est <span class="op">&gt;=</span> threshold))</span>
<span id="cb130-78"><a href="#cb130-78" aria-hidden="true" tabindex="-1"></a>                              <span class="cf">for</span> (est, true_r) <span class="kw">in</span> playing_count[:k])</span>
<span id="cb130-79"><a href="#cb130-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-80"><a href="#cb130-80" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Precision@K: Proportion of recommended items that are relevant</span></span>
<span id="cb130-81"><a href="#cb130-81" aria-hidden="true" tabindex="-1"></a>        <span class="co"># When n_rec_k is 0, Precision is undefined. We here set Precision to 0 when n_rec_k is 0.</span></span>
<span id="cb130-82"><a href="#cb130-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-83"><a href="#cb130-83" aria-hidden="true" tabindex="-1"></a>        precisions[uid] <span class="op">=</span> n_rel_and_rec_k <span class="op">/</span> n_rec_k <span class="cf">if</span> n_rec_k <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb130-84"><a href="#cb130-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-85"><a href="#cb130-85" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Recall@K: Proportion of relevant items that are recommended</span></span>
<span id="cb130-86"><a href="#cb130-86" aria-hidden="true" tabindex="-1"></a>        <span class="co"># When n_rel is 0, Recall is undefined. We here set Recall to 0 when n_rel is 0.</span></span>
<span id="cb130-87"><a href="#cb130-87" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-88"><a href="#cb130-88" aria-hidden="true" tabindex="-1"></a>        recalls[uid] <span class="op">=</span> n_rel_and_rec_k <span class="op">/</span> n_rel <span class="cf">if</span> n_rel <span class="op">!=</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb130-89"><a href="#cb130-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-90"><a href="#cb130-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-91"><a href="#cb130-91" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Mean of all the predicted precisions are calculated.</span></span>
<span id="cb130-92"><a href="#cb130-92" aria-hidden="true" tabindex="-1"></a>    precision <span class="op">=</span> <span class="bu">round</span>((<span class="bu">sum</span>(prec <span class="cf">for</span> prec <span class="kw">in</span> precisions.values()) <span class="op">/</span> <span class="bu">len</span>(precisions)),<span class="dv">3</span>)</span>
<span id="cb130-93"><a href="#cb130-93" aria-hidden="true" tabindex="-1"></a>    <span class="co">#Mean of all the predicted recalls are calculated.</span></span>
<span id="cb130-94"><a href="#cb130-94" aria-hidden="true" tabindex="-1"></a>    recall <span class="op">=</span> <span class="bu">round</span>((<span class="bu">sum</span>(rec <span class="cf">for</span> rec <span class="kw">in</span> recalls.values()) <span class="op">/</span> <span class="bu">len</span>(recalls)),<span class="dv">3</span>)</span>
<span id="cb130-95"><a href="#cb130-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-96"><a href="#cb130-96" aria-hidden="true" tabindex="-1"></a>    <span class="co">#accuracy.rmse(predictions)</span></span>
<span id="cb130-97"><a href="#cb130-97" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Precision: '</span>, precision) <span class="co">#Command to print the overall precision</span></span>
<span id="cb130-98"><a href="#cb130-98" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'Recall: '</span>, recall) <span class="co">#Command to print the overall recall</span></span>
<span id="cb130-99"><a href="#cb130-99" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">'F_1 score: '</span>, <span class="bu">round</span>((<span class="dv">2</span><span class="op">*</span>precision<span class="op">*</span>recall)<span class="op">/</span>(precision<span class="op">+</span>recall),<span class="dv">3</span>)) <span class="co"># Formula to compute the F-1 score.</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="39566ebd" class="cell">
<div class="sourceCode cell-code" id="cb131"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="co"># getting the prediction for each user-pair of the testset</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a>user_est_true_lfm <span class="op">=</span> get_predictions(basic_lfm, df_final, dataset, test_interactions)</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>ests <span class="op">=</span> user_est_true_lfm[<span class="dv">1</span>]</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'min_est_score:'</span>, <span class="bu">min</span>(ests))</span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'max_est_score:'</span>, <span class="bu">max</span>(ests))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e427a461" class="cell">
<div class="sourceCode cell-code" id="cb132"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a><span class="co"># evaluate the model with a threshold</span></span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k_lfm(user_est_true<span class="op">=</span>user_est_true_lfm[<span class="dv">0</span>], threshold<span class="op">=-</span><span class="dv">1</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="rebuilidng-the-model-by-transforming-the-item-features-with-a-vectorizer" class="level3" data-number="10.2">
<h3 data-number="10.2" class="anchored" data-anchor-id="rebuilidng-the-model-by-transforming-the-item-features-with-a-vectorizer"><span class="header-section-number">10.2</span> Rebuilidng the model by transforming the item features with a vectorizer</h3>
<div id="59bd6a82" class="cell">
<div class="sourceCode cell-code" id="cb133"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Taking a sample of the dataset</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>df_final <span class="op">=</span> df_final.sample(<span class="dv">3000</span>, random_state<span class="op">=</span><span class="dv">42</span>)</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Defining users and songs sets</span></span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a>user_ids <span class="op">=</span> <span class="bu">set</span>(df_final.user_id)</span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>songs_ids <span class="op">=</span> <span class="bu">set</span>(df_final.song_id)</span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Defining user features</span></span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a>nbr_user_listened_songs <span class="op">=</span> df_final.groupby(<span class="st">'user_id'</span>).play_count.count()</span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a>nbr_user_listened_songs <span class="op">=</span> nbr_user_listened_songs <span class="op">/</span> nbr_user_listened_songs.values.<span class="bu">sum</span>()</span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Defining songs features</span></span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a>df_final[<span class="st">'text'</span>] <span class="op">=</span> df_final[<span class="st">'title'</span>] <span class="op">+</span> <span class="st">' '</span> <span class="op">+</span> df_final[<span class="st">'release'</span>] <span class="op">+</span> <span class="st">' '</span> <span class="op">+</span>  df_final[<span class="st">'artist_name'</span>]</span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-15"><a href="#cb133-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Create tfidf vectorizer</span></span>
<span id="cb133-16"><a href="#cb133-16" aria-hidden="true" tabindex="-1"></a>tfidf <span class="op">=</span> TfidfVectorizer(tokenizer <span class="op">=</span> tokenize)</span>
<span id="cb133-17"><a href="#cb133-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-18"><a href="#cb133-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Creating the songs tfidf</span></span>
<span id="cb133-19"><a href="#cb133-19" aria-hidden="true" tabindex="-1"></a>songs_tfidf <span class="op">=</span> tfidf.fit_transform(df_final[<span class="st">'text'</span>].values).toarray()</span>
<span id="cb133-20"><a href="#cb133-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-21"><a href="#cb133-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a Dataset object and fit users, songs, and features</span></span>
<span id="cb133-22"><a href="#cb133-22" aria-hidden="true" tabindex="-1"></a>dataset <span class="op">=</span> Dataset()</span>
<span id="cb133-23"><a href="#cb133-23" aria-hidden="true" tabindex="-1"></a>dataset.fit(users<span class="op">=</span>user_ids, items<span class="op">=</span>songs_ids,</span>
<span id="cb133-24"><a href="#cb133-24" aria-hidden="true" tabindex="-1"></a>            user_features <span class="op">=</span> <span class="bu">set</span>(nbr_user_listened_songs),</span>
<span id="cb133-25"><a href="#cb133-25" aria-hidden="true" tabindex="-1"></a>            item_features <span class="op">=</span> <span class="bu">set</span>(songs_tfidf.ravel()))</span>
<span id="cb133-26"><a href="#cb133-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-27"><a href="#cb133-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-28"><a href="#cb133-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Build interactions and features</span></span>
<span id="cb133-29"><a href="#cb133-29" aria-hidden="true" tabindex="-1"></a>interactions <span class="op">=</span> [(x[<span class="dv">0</span>], x[<span class="dv">1</span>], x[<span class="dv">2</span>]) <span class="cf">for</span> x <span class="kw">in</span> df_final[[<span class="st">'user_id'</span>, <span class="st">'song_id'</span>, <span class="st">'play_count_scaled'</span>]].values]</span>
<span id="cb133-30"><a href="#cb133-30" aria-hidden="true" tabindex="-1"></a>(interactions, weights) <span class="op">=</span> dataset.build_interactions(interactions)</span>
<span id="cb133-31"><a href="#cb133-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-32"><a href="#cb133-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-33"><a href="#cb133-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Split the interactions matrix into a train and test set</span></span>
<span id="cb133-34"><a href="#cb133-34" aria-hidden="true" tabindex="-1"></a>test_ratio <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb133-35"><a href="#cb133-35" aria-hidden="true" tabindex="-1"></a>train_interactions, test_interactions <span class="op">=</span> random_train_test_split(interactions, test_percentage<span class="op">=</span>test_ratio, random_state<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb133-36"><a href="#cb133-36" aria-hidden="true" tabindex="-1"></a>train_weights, test_weights <span class="op">=</span> random_train_test_split(weights, test_percentage<span class="op">=</span>test_ratio, random_state<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb133-37"><a href="#cb133-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-38"><a href="#cb133-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-39"><a href="#cb133-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Builiding user features</span></span>
<span id="cb133-40"><a href="#cb133-40" aria-hidden="true" tabindex="-1"></a>user_features <span class="op">=</span> <span class="bu">list</span>(<span class="bu">zip</span>(nbr_user_listened_songs.index, nbr_user_listened_songs.<span class="bu">apply</span>(<span class="kw">lambda</span> x: [x])))</span>
<span id="cb133-41"><a href="#cb133-41" aria-hidden="true" tabindex="-1"></a>user_features <span class="op">=</span> dataset.build_user_features(user_features)</span>
<span id="cb133-42"><a href="#cb133-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-43"><a href="#cb133-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-44"><a href="#cb133-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Builiding items features</span></span>
<span id="cb133-45"><a href="#cb133-45" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Map item IDs to the order of the TF-IDF matrix</span></span>
<span id="cb133-46"><a href="#cb133-46" aria-hidden="true" tabindex="-1"></a>item_features_map <span class="op">=</span> <span class="bu">dict</span>(<span class="bu">zip</span>(songs_ids, songs_tfidf))</span>
<span id="cb133-47"><a href="#cb133-47" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Fit the dataset with item features</span></span>
<span id="cb133-48"><a href="#cb133-48" aria-hidden="true" tabindex="-1"></a>dataset.fit_partial(items<span class="op">=</span>songs_ids, item_features<span class="op">=</span><span class="bu">range</span>(songs_tfidf.shape[<span class="dv">1</span>]))</span>
<span id="cb133-49"><a href="#cb133-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-50"><a href="#cb133-50" aria-hidden="true" tabindex="-1"></a>itl <span class="op">=</span> []</span>
<span id="cb133-51"><a href="#cb133-51" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Build the item features list</span></span>
<span id="cb133-52"><a href="#cb133-52" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item_id <span class="kw">in</span> songs_ids:</span>
<span id="cb133-53"><a href="#cb133-53" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i, value <span class="kw">in</span> <span class="bu">enumerate</span>(item_features_map[item_id]):</span>
<span id="cb133-54"><a href="#cb133-54" aria-hidden="true" tabindex="-1"></a>    itl.append((item_id, (i, value)))</span>
<span id="cb133-55"><a href="#cb133-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-56"><a href="#cb133-56" aria-hidden="true" tabindex="-1"></a>item_features <span class="op">=</span> dataset.build_item_features(itl)</span>
<span id="cb133-57"><a href="#cb133-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-58"><a href="#cb133-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-59"><a href="#cb133-59" aria-hidden="true" tabindex="-1"></a>vectorized_lfm <span class="op">=</span> LightFM(</span>
<span id="cb133-60"><a href="#cb133-60" aria-hidden="true" tabindex="-1"></a>    no_components<span class="op">=</span><span class="dv">150</span>,</span>
<span id="cb133-61"><a href="#cb133-61" aria-hidden="true" tabindex="-1"></a>    learning_rate<span class="op">=</span><span class="fl">0.05</span>,</span>
<span id="cb133-62"><a href="#cb133-62" aria-hidden="true" tabindex="-1"></a>    loss<span class="op">=</span><span class="st">'warp'</span>,</span>
<span id="cb133-63"><a href="#cb133-63" aria-hidden="true" tabindex="-1"></a>    random_state<span class="op">=</span><span class="dv">200</span>)</span>
<span id="cb133-64"><a href="#cb133-64" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-65"><a href="#cb133-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-66"><a href="#cb133-66" aria-hidden="true" tabindex="-1"></a>vectorized_lfm.fit(train_interactions,</span>
<span id="cb133-67"><a href="#cb133-67" aria-hidden="true" tabindex="-1"></a>          sample_weight<span class="op">=</span>train_weights,</span>
<span id="cb133-68"><a href="#cb133-68" aria-hidden="true" tabindex="-1"></a>          user_features<span class="op">=</span>user_features,</span>
<span id="cb133-69"><a href="#cb133-69" aria-hidden="true" tabindex="-1"></a>          item_features<span class="op">=</span>item_features,</span>
<span id="cb133-70"><a href="#cb133-70" aria-hidden="true" tabindex="-1"></a>          epochs<span class="op">=</span><span class="dv">50</span>, num_threads<span class="op">=</span><span class="dv">50</span>, verbose<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="41b83119" class="cell">
<div class="sourceCode cell-code" id="cb134"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Evaluating the model with lightfm evaluation metrics</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>evaluate_lfm_model(vectorized_lfm, test_interactions, user_features,</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>                   item_features, <span class="dv">30</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The AUC has not improved - It is due to the small number of observations used to train the model. - With the same number of observations this approach gives a slightly better performance.</p>
<div id="b82bd93a" class="cell">
<div class="sourceCode cell-code" id="cb135"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="co"># getting the prediction for each user-pair of the testset</span></span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a>user_est_true_lfm <span class="op">=</span> get_predictions(vectorized_lfm, df_final, dataset, test_interactions)</span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>ests <span class="op">=</span> user_est_true_lfm[<span class="dv">1</span>]</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'min_est_score:'</span>, <span class="bu">min</span>(ests))</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'max_est_score:'</span>, <span class="bu">max</span>(ests))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e1e34deb" class="cell">
<div class="sourceCode cell-code" id="cb136"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="co"># evaluate the model with a threshold in Surprise manner</span></span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>precision_recall_at_k_lfm(user_est_true<span class="op">=</span>user_est_true_lfm[<span class="dv">0</span>], threshold<span class="op">=-</span><span class="fl">0.01</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>With no surprise the threshold evaluation f1 score is not better.</p>
</section>
</section>
<section id="final-conclusion" class="level2" data-number="11">
<h2 data-number="11" class="anchored" data-anchor-id="final-conclusion"><span class="header-section-number">11</span> Final Conclusion</h2>
<p><strong>We improved the F1 score of the user user collaborative filtering model by 0.15 points (0.66 vs 0.51 before)</strong> just by: - changing the <strong>cutoffs thresholds</strong> - <strong>dropping old observations</strong> - <strong>caping the play counts</strong> greater than 5 <strong>to 5</strong>.</p>
<p>Balancing the data and creating a custom Random Forest model have not improved the performance.</p>
<p>We have also built an <strong>hybrid recommendation system</strong> using the LightFm library. The AUC obtained with a basic hybrid model is 0.76. The results can be improved provided: - more computer power to perform the training. - more data on users, for example demographic or behavior data. - more data on songs, for example the genre or the category of a song.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>